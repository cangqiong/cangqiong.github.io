<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chason&#39;s Blog.渺沧海之一粟</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cangqiong.github.io/"/>
  <updated>2018-04-15T09:38:42.701Z</updated>
  <id>https://cangqiong.github.io/</id>
  
  <author>
    <name>Chason</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://cangqiong.github.io/2018/04/15/regular-expression/"/>
    <id>https://cangqiong.github.io/2018/04/15/regular-expression/</id>
    <published>2018-04-15T09:35:25.000Z</published>
    <updated>2018-04-15T09:38:42.701Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在日常工作中，编辑文本或网页的时候，经常会用磁盘搜索功能或者在文本中搜索某个单词。例如：用记事本打开个文档后，搜索“测试”，就可以匹配到当前文档中“测试”这个词。</p><p>那有没有更加强大的文本匹配工具，给开发人员或者运维人员使用呢？一种不需要知道要匹配的值，只需知道要匹配的值满足的规则。这就要提起从Unix系统就开始使用的正则表达式了。<strong>正则表达式（regular expression）其实就是使用特定字符来匹配符合特殊字符确定的规则的字符串</strong>。</p><p>其实正则表达式日常办公中，也经常使用。比如你打开文件管理器，在右边的搜索框，搜索“*.txt”，就能搜到当前目录下的所有txt文件。这其实这就可以看成是正则表达式。</p></blockquote><p>#元字符</p><p>上面说了正则表达式是使用特定字符来匹配想要的字符串。特定字符这里称为<strong>元字符</strong>。下面先看一个简单的实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grep -P "^test$" doc.txt</span><br><span class="line"><span class="meta">#</span> grep 这是Linux自带的正则shell方法</span><br><span class="line"><span class="meta">#</span> -P 表示采用Perl的正则表达式引擎，其实不加这个也可以，但有些元字符用不了</span><br><span class="line"><span class="meta">#</span> "^test$" 为正则表达式，其中^与$为元字符，test为普通字符</span><br><span class="line"><span class="meta">#</span> doc.txt 匹配的目标文档</span><br></pre></td></tr></table></figure><p>如上所述：<code>^</code>与<code>$</code>为元字符,<code>^</code>表示一行的开始，而<code>$</code>为一行的结束，上面的正则表达式的含义是：匹配以<em>test</em>开头语且以<em>test</em>结尾的字符串。</p><p>其中doc.txt的文本为</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">subject:测试正则表达式</span><br><span class="line">from: test123@163.com</span><br><span class="line">to: test456@163.com</span><br><span class="line">dear one:</span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">  <span class="built_in">test</span></span><br><span class="line">        today has a rain.</span><br><span class="line">TODAY IS A GOOD DAY</span><br><span class="line">abcderfghghghg</span><br><span class="line">123892332432</span><br><span class="line">789</span><br><span class="line">020-12345678</span><br><span class="line">telethone:020-79788888</span><br><span class="line">dfdf22测试中文字符串</span><br><span class="line">\s\d\S\w</span><br><span class="line">ip:22.105.145.123</span><br><span class="line">              the best wish!.</span><br></pre></td></tr></table></figure><p>上面的执行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaocanghai regex]# grep -P "^test$" doc.txt</span><br><span class="line">test</span><br></pre></td></tr></table></figure><p>那如果要搜索电话号码呢？可以用下面的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaocanghai regex]# grep -P "\w+@\w+\.\w+" doc.txt</span><br><span class="line">from: test123@163.com</span><br><span class="line">to: test456@163.com</span><br></pre></td></tr></table></figure><p>上面的<code>\w</code>明显就是元字符，它表示一个单词，指字母或数字或者小划线。常用的元字符如下所示</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>匹配除换行符以外的任意字符</td></tr><tr><td>\w</td><td>匹配字母或数字或下划线或汉字</td></tr><tr><td>\s</td><td>匹配任意的空白符</td></tr><tr><td>\d</td><td>匹配数字</td></tr><tr><td>\b</td><td>匹配单词的开始或结束</td></tr><tr><td>^</td><td>匹配字符串的开始</td></tr><tr><td>$</td><td>匹配字符串的结束</td></tr></tbody></table><p>那如果想匹配其中某个词，可以用<code>\b</code>+词+<code>\b</code>进行搜索，比如搜索a，只想搜索到词a（一个），而不是字母a。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaocanghai regex]# grep -P "\ba\b" doc.txt</span><br><span class="line">        today has a rain.</span><br></pre></td></tr></table></figure><p>#量词</p><p>那如果想搜索上面文本的电话号码，按照给定的元字符，可以这样搜索：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaocanghai regex]# grep -P "0\d\d-\d\d\d\d\d\d\d\d" doc.txt</span><br><span class="line">020-12345678</span><br><span class="line">telethone:020-79788888</span><br></pre></td></tr></table></figure><p>但感觉是不是有点麻烦，上面的元字符只能匹配一个字符，匹配电话号码，还得10个元字符，这也太麻烦了，可以采用量词进行匹配：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaocanghai regex]# grep -P "0\d&#123;2&#125;-\d&#123;8&#125;" doc.txt</span><br><span class="line">020-12345678</span><br><span class="line">telethone:020-79788888</span><br></pre></td></tr></table></figure><p>上面的{2}表示匹配两个满足\d规则的字符，{8}自然是匹配八个满足\d规则的字符。除了这种量词，还有其他量词</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>重复零次或更多次</td></tr><tr><td>+</td><td>重复一次或更多次</td></tr><tr><td>?</td><td>重复零次或一次</td></tr><tr><td>{n}</td><td>重复n次</td></tr><tr><td>{n,}</td><td>重复n次或更多次</td></tr><tr><td>{n,m}</td><td>重复n到m次</td></tr></tbody></table><p>量词其实就是对前面的元字符的个数的描述。比如想匹配第一行以a开头的字符串：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaocanghai regex]# grep -P "^a\w*" doc.txt</span><br><span class="line">abcderfghghghg</span><br><span class="line"><span class="meta">#</span><span class="bash"> ^a\w* 表示以a开头后面的字符不限的字符串</span></span><br></pre></td></tr></table></figure><p>#自定义字符</p><p>使用指定的元字符与普通字符进行能够匹配指定的字符串，但是如果自己想匹配没有预定义元字符的字符集合时，那怎么操作呢？比如查找包含元音字母的单词，怎么办。</p><p>很简单，只需要在中括号中列出来就可以了，<code>[aeiou]</code>表示aeiou中的任意字符，<code>[!?*]</code>表示其中任一字符，记住**方括号括起来的的只匹配一个字符，可以使用量词进行匹配多个字符。<code>[0-9]</code> 代表的含意与 <code>\d</code> 就是完全一致的，表示从0到9的数字，中括号中的<code>-</code>表示0与9之前的区间，即一个数字。同理 <code>[a-z0-9A-Z_]</code> 也完全等同于 <code>\w</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaocanghai regex]# grep -P &quot;\b\w*[0-9]\w*\b&quot; doc.txt #匹配包含数字的词</span><br><span class="line">from: test123@163.com</span><br><span class="line">to: test456@163.com</span><br><span class="line">123892332432</span><br><span class="line">789</span><br><span class="line">020-12345678</span><br><span class="line">telethone:020-79788888</span><br><span class="line">dfdf22测试中文字符</span><br></pre></td></tr></table></figure><p>#转义字符</p><p>通过上面的介绍，可以匹配大多数的字符串，但如果想匹配元字符对应的字符串呢？那就要用到转义字符了。</p><p>比如想匹配<code>.</code>，就可以采取加<code>\</code>的方式进行转义，这样就会取消元字符的含义。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaocanghai regex]# grep -P "\.$" doc.txt  #可以试一下不加\</span><br><span class="line">        today has a rain.</span><br><span class="line">              the best wish!.</span><br></pre></td></tr></table></figure><p>#选择符与分组</p><p>如果想匹配满足多个表达式的字符串，这就要用到<code>|</code>，它表示或，也就是说满足两个表达式的一个就可以了。假设要搜索邮件的收件人与发件人，收件人可以用<code>^to:\w</code>*，而发件人可以用<code>^from:\w</code>,两个条件综合就是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaocanghai regex]# grep -P "^(from|to)\w*" doc.txt</span><br><span class="line">from: test123@163.com</span><br><span class="line">to: test456@163.com</span><br></pre></td></tr></table></figure><p>上面的<code>(</code> 与<code>)</code>也是元字符串，可以用括号指定子表达式，也叫做分组，也可以用量词表示字表达试的次数，比如匹配IP：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaocanghai regex]# grep -P "(\d&#123;1,3&#125;\.)&#123;3&#125;\d&#123;1,3&#125;" doc.txt</span><br><span class="line">ip:22.105.145.123</span><br></pre></td></tr></table></figure><p>#实例</p><p>上面讲了如何写正则表达式，下面举几个例子说明一下正则的用途。</p><h2 id="nginx静态资源配置"><a href="#nginx静态资源配置" class="headerlink" title="nginx静态资源配置"></a>nginx静态资源配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location ~* ^.+\.(jpg|jpeg|gif|css|png|js|ico|html|txt)$ &#123; #对静态资源进行访问</span><br><span class="line">       access_log        off;</span><br><span class="line">       expires           30d;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>上面的<code>^.+\.(jpg|jpeg|gif|css|png|js|ico|html|txt)$</code>字符串就是正则表达式，匹配的是任意字符为前缀以<code>.txt/jpg/...</code>结尾的URL字符串。</p><h2 id="爬虫匹配链接"><a href="#爬虫匹配链接" class="headerlink" title="爬虫匹配链接"></a>爬虫匹配链接</h2><p>在网络爬虫中，为了抓取外链，需要通过正则表达式匹配链接。可以匹配网页html代码中的<code>&lt;a&gt;</code>链接，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a\b("[^"]*"|'[^']*'|[^'"&gt;])*&gt;</span><br></pre></td></tr></table></figure><h1 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h1><p>正则表达式有点难以理解，但功能其实很强大，其实还有其他内容没有介绍，可以看我给出的参考资料。</p><ul><li><p>文章<br>《正则表达式30分钟入门教程》</p><p>《正则表达式经典实例》</p></li><li><p>在线解析工具：<a href="https://regexper.com" target="_blank" rel="noopener">https://regexper.com</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在日常工作中，编辑文本或网页的时候，经常会用磁盘搜索功能或者在文本中搜索某个单词。例如：用记事本打开个文档后，搜索“测试”，就可以匹配到当前文档中“测试”这个词。&lt;/p&gt;
&lt;p&gt;那有没有更加强大的文本匹配工具，给开发人员或者运维人员使用呢？一种不需
      
    
    </summary>
    
      <category term="2018" scheme="https://cangqiong.github.io/categories/2018/"/>
    
      <category term="学习" scheme="https://cangqiong.github.io/categories/2018/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="总结" scheme="https://cangqiong.github.io/categories/2018/%E5%AD%A6%E4%B9%A0/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="正则表达式" scheme="https://cangqiong.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="实例" scheme="https://cangqiong.github.io/tags/%E5%AE%9E%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务</title>
    <link href="https://cangqiong.github.io/2018/04/07/database-transaction/"/>
    <id>https://cangqiong.github.io/2018/04/07/database-transaction/</id>
    <published>2018-04-07T12:43:25.000Z</published>
    <updated>2018-04-07T12:47:10.472Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数据库事务（Transaction）是指数据库管理系统执行过程中一个不可分割的逻辑单元，由有限的数据库操作语句组成。</p></blockquote><p>事务的执行步骤：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line">SQL execution 1 # rollback</span><br><span class="line">SQL execution 2 # rollback</span><br><span class="line">...</span><br><span class="line">SQL execution N # rollback</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>begin标识开始一个事务，后面的SQL语句是事务执行的操作，commit（提交）是结束当前事务并提交事务。而在语句执行过程中，可以回滚事务(Rollback)，回滚是指将数据恢复成事务开始之前的状态。</p><h1 id="为什么需要事务？"><a href="#为什么需要事务？" class="headerlink" title="为什么需要事务？"></a>为什么需要事务？</h1><p>数据库有自己的SQL语句，用户可以使用SQL语句操作数据库，那为什么需要事务呢？SQL语句能够直接修改数据库中的数据，但却无法保证数据的一致性。比如经典的转账问题：账户A向账户B转账，只用SQL语句无法保证从账户A扣款成功，同时从账户B增加对应的金额。所以<strong>事务是为了保证数据库中数据的一致性。</strong></p><h1 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h1><p>事务特性有哪些特性呢？</p><ul><li>原子性（Atomicity）:事务作为一个整体被执行，事务中的操作要么全部被执行，要么都不执行。</li><li>一致性（Consistency）：事务应确保数据库的状态一一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。不能存在事务对数据部分修改的情况。</li><li>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应该影响其他事务的执行。</li><li>持久性（Durability）：已经提交的事务对数据库的修改应该永远保存在数据库中。对数据库数据的修改应该持久化到硬盘中，即使服务器当机了，只要数据库能正常访问，就一定能够恢复事务成功结束时的标志。</li></ul><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>为说明数据库的特性，举一个经典的事务案例，账户Ａ向账号Ｂ转账100元，假设账户Ａ有800元，账户B有300元。要完成这个转账操作需要执行下面事务所包含的所有步骤，才能转账成功。</p><ol><li>读取账户A金额800元。</li><li>对账户A扣取100元，帐户A变为700元（内存）。</li><li>将结果700元写入到A账户中（硬盘）。</li><li>读取账户B金额300元。</li><li>对帐户B进行增加100元，账户B变为400元（内存）。</li><li>将结果400元写入到B账户中（硬盘）。</li></ol><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>原子性保证事务中的所有操作必须全部执行，或全部不执行。上面的转账事务包含6个操作，原子性保证上面的6个操作必须全部执行成功，转账事务才能成功。如果在第2步账号A金额不够100元，转账失败，事务<strong>回滚</strong>。如果在第6步，突然系统断电或系统崩溃，整个事务还是得回滚。<strong>回滚</strong>是指将数据恢复到事务执行之前的状态，也就相当于事务中的操作都不执行。</p><h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>一致性是指数据库中的数据从一个一致性状态转变到另一个一致性。不能出现部分修改数据的情况。在上面的案例中，转账前账号A与账号B金额总和是1100，转账后还是1100，这就是一致性。不能出现账户A扣钱成功，但账号B没收到钱，那肯定有问题了。</p><h2 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h2><p>在事务执行成功之前，即没有完成commit之前，查询账户A与账号B的金额，还是事务执行之前的数目。其他和A、B相关的并发转账事务或其他事务对当前转账不产生影响。</p><h2 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h2><p>当事务commit之后，即事务执行完成的时候，账户A与账户B的金额变成事务执行之后的数目，并持久化到硬盘中，之后的查询可以看到改变后的金额。即使系统故障，该事务也必须永久性生效。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;数据库事务（Transaction）是指数据库管理系统执行过程中一个不可分割的逻辑单元，由有限的数据库操作语句组成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;事务的执行步骤：&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="2018" scheme="https://cangqiong.github.io/categories/2018/"/>
    
      <category term="技术总结" scheme="https://cangqiong.github.io/categories/2018/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="DB" scheme="https://cangqiong.github.io/tags/DB/"/>
    
      <category term="事务" scheme="https://cangqiong.github.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="https://cangqiong.github.io/2018/03/31/strategy-pattern/"/>
    <id>https://cangqiong.github.io/2018/03/31/strategy-pattern/</id>
    <published>2018-03-31T08:56:36.799Z</published>
    <updated>2018-03-31T08:59:51.476Z</updated>
    
    <content type="html"><![CDATA[<p>策略模式是比较常用也容易理解，它还充分体现了面向对象设计的原则：<strong>封装变化</strong>。</p><blockquote><p>策略模式(Strategy Pattern)是定义一组算法（业务规则），封装每个算法，这组算法可以相互替换。它是将算法的使用与实现进行分离。</p></blockquote><h1 id="策略模式介绍"><a href="#策略模式介绍" class="headerlink" title="策略模式介绍"></a>策略模式介绍</h1><p><img src="https://upload.wikimedia.org/wikipedia/commons/3/39/Strategy_Pattern_in_UML.png" alt="策略模式类图"></p><p>​                                        <strong>策略模式类图</strong></p><p>如上图所示，策略模式分为三个角色：</p><blockquote><p>Context 上下文</p><p>stategy 策略接口类</p><p>ConcreteStrategyA 具体策略类</p></blockquote><h1 id="不使用策略模式的例子"><a href="#不使用策略模式的例子" class="headerlink" title="不使用策略模式的例子"></a>不使用策略模式的例子</h1><p>先介绍一下不使用策略模式的例子。电影院的收银员肯定根据不同的客户进行分别收费，假设普通客户是原价，而VIP用户打88折，学生打九折。按照最普通的思路是这样实现的：</p><p>首先设计一个客户接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getType</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getTicketPrice</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后设计收银员进行收费：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CinemaCashier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 收费</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cashier</span><span class="params">(Member member)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"student"</span>.equals(member.getType())) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0.9</span>*member.getTicketPrice();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"vip"</span>.equals(member.getType())) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0.88</span>*member.getTicketPrice();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> member.getTicketPrice();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际收费流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.chason.patterns.strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cinema</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CinemaCashier cashier = <span class="keyword">new</span> CinemaCashier();</span><br><span class="line">    Member steudent = <span class="keyword">new</span> Student(<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">double</span> price = cashier.cashier(steudent);</span><br><span class="line">    System.out.println(steudent.getType() + <span class="string">":"</span> + price);</span><br><span class="line"></span><br><span class="line">    Member vip = <span class="keyword">new</span> Vip(<span class="number">30</span>);</span><br><span class="line">    price = cashier.cashier(vip);</span><br><span class="line">    System.out.println(vip.getType() + <span class="string">":"</span> + price);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line"><span class="comment">//student:27.0</span></span><br><span class="line"><span class="comment">//vip:26.4</span></span><br></pre></td></tr></table></figure><p>上面的收银员根据不同的用户类型采用不同的收费策略，这里采用if/else实现，这是最直接的实现方式。<strong>但是</strong>突然老板说要加一种超级会员，这就很无语了，超级会员实现上面的会员接口就可以了，但收费的行为逻辑就必须改动了，得再加一个逻辑判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cashier</span><span class="params">(Member member)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="string">"student"</span>.equals(member.getType())) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0.9</span>*member.getTicketPrice();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"vip"</span>.equals(member.getType())) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0.88</span>*member.getTicketPrice();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"vip+"</span>.equals(member.getType())) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0.8</span>*member.getTicketPrice();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> member.getTicketPrice();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>虽然看起来改动很小，但往往会导致代码的臃肿与腐烂。那导致上面的原因是什么呢？<strong>没有将变化进行封装。</strong></p><h1 id="使用策略模式进行改造"><a href="#使用策略模式进行改造" class="headerlink" title="使用策略模式进行改造"></a>使用策略模式进行改造</h1><p>下面采用策略模式进行改造。</p><p>首先是对客户类的封装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getType</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getTicketPrice</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">cashier</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收银员类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CinemaCashier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Member member;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 收费</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cashier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> member.cashier();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMember</span><span class="params">(Member member)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.member = member;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cinema</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CinemaCashier context = <span class="keyword">new</span> CinemaCashier();</span><br><span class="line"></span><br><span class="line">    Member strategy  = <span class="keyword">new</span> Student(<span class="number">30</span>);</span><br><span class="line">    cashier.setMember(strategy);</span><br><span class="line">    <span class="keyword">double</span> price = cashier.cashier();</span><br><span class="line">    System.out.println(strategy .getType() + <span class="string">":"</span> + price);</span><br><span class="line"></span><br><span class="line">    strategy  = <span class="keyword">new</span> Vip(<span class="number">30</span>);</span><br><span class="line">    cashier.setMember(strategy );</span><br><span class="line">    price = cashier.cashier();</span><br><span class="line">    System.out.println(strategy.getType() + <span class="string">":"</span> + price);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加新的收费策略</span></span><br><span class="line">    strategy  = <span class="keyword">new</span> VipPlus(<span class="number">30</span>);</span><br><span class="line">    cashier.setMember(strategy);</span><br><span class="line">    price = cashier.cashier();</span><br><span class="line">    System.out.println(strategy.getType() + <span class="string">":"</span> + price);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过改造后的代码，关键就在于针对不同用户的收费策略封装在不同对象中（本文是把策略方法直接放在用户对象中）。不同的策略对象是可以进行替换，并且context在确定的时间只能使用一种策略。当策略方法需要改动，或增加新的策略时，可以只用改动少量的代码或只用加代码就可以实现新功能的添加。</p><p>#总结</p><p>策略模式采用封装变化的方法，实现一组可以相互替换的算法或业务规则，而使用算法的应用环境或者说上下文根据具体情况决定采取哪一种策略。这样算法的实现与使用进行分离开来。算法的改动不会应用到算法的使用或其他算法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;策略模式是比较常用也容易理解，它还充分体现了面向对象设计的原则：&lt;strong&gt;封装变化&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;策略模式(Strategy Pattern)是定义一组算法（业务规则），封装每个算法，这组算法可以相互替换。它是将算法的使用
      
    
    </summary>
    
      <category term="2018" scheme="https://cangqiong.github.io/categories/2018/"/>
    
      <category term="技术总结" scheme="https://cangqiong.github.io/categories/2018/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="设计模式" scheme="https://cangqiong.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java代理</title>
    <link href="https://cangqiong.github.io/2018/03/25/java-and-proxy/"/>
    <id>https://cangqiong.github.io/2018/03/25/java-and-proxy/</id>
    <published>2018-03-25T14:10:25.000Z</published>
    <updated>2018-03-25T14:07:22.580Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在使用Java的过程中，逐渐开始了解设计模式，其中代理模式是其中比较简单的设计模式，日常工作中也经常接触到代理模式的使用。</p></blockquote><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>代理模式（Proxy Pattern）使用代理对象完成用户请求，隐藏用户对真实对象的访问。代理模式其实非常容易理解。举个简单的例子： 小刘要找个房子，但他找房子并没有直接和房东联系，而是和中介联系。对于小刘而言，他作为客户并没有和房东（真实对象）打交道，只和中介（代理对象）沟通。似乎房东不存在，但事实上中介必须得有房东的授权，在核心问题上还得请示房东。</p><p>在软件设计中，使用代理模式的场景也很多，比如为了系统的安全性屏蔽客户端访问真实的对象，或者为了屏蔽真实对象的实现细节，也可能是为了提升系统性能，对真实对象进行封装，到使用时候才进行初始化，从而达到延迟加载的目的。</p><h2 id="代理模式架构"><a href="#代理模式架构" class="headerlink" title="代理模式架构"></a>代理模式架构</h2><p>代理模式架构比较简单，如下图所示，</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/75/Proxy_pattern_diagram.svg/439px-Proxy_pattern_diagram.svg.png" alt="代理模式图片"></p><p>​                                        代理模式架构图</p><p>代理对象与真实对象实现同一主题接口，当客户端向真实对象发起请求时，代理对象调用真实对象进行操作。</p><h2 id="代理模式简单样例"><a href="#代理模式简单样例" class="headerlink" title="代理模式简单样例"></a>代理模式简单样例</h2><p>下面给出一个代码样例。</p><p><strong>主题接口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ISubject</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">doAction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>真实对象：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealObject</span> <span class="keyword">implements</span> <span class="title">ISubject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doAction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"RealObject do something!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Real object"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主题接口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyObject</span> <span class="keyword">implements</span> <span class="title">ISubject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RealObject realObject;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doAction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(realObject == <span class="keyword">null</span>) &#123;  <span class="comment">// 在真正使用的时候，才创建真实对象</span></span><br><span class="line">            realObject = <span class="keyword">new</span> RealObject();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"ProxyObject do something!"</span>);</span><br><span class="line">        <span class="comment">// 执行真实对象的方法</span></span><br><span class="line">        <span class="keyword">return</span> realObject.doAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"> ISubject subject = <span class="keyword">new</span> ProxyObject(); <span class="comment">//使用代理</span></span><br><span class="line"> subject.doAction(); </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>上面的代码实例是静态代理，下面介绍动态代理。动态代理是指在运行时动态生成代理类。</p><p>刚才的静态代理虽然看起来简单，但其实有很多缺点：</p><ol><li><p>代理类与真实类实现了相同的主题接口，代理对象与真实对象实现了相同的方法。这样就会出现大量的代码重复。如果主题接口增加一个方法，除了真实对象要实现这个方法外，代理对象也要实现这个方法。这样增加了维护的复杂度。</p></li><li><p>代理对象只能代理一种类型的对象。如果要代理多种类型的对象的话。每个真实对象都必须要有对应的代理对象。</p><p>​</p></li></ol><p>如果可以通过一个代理类完成全部的代理的功能，那就需要使用动态代理。静态代理是在编译阶段就已经确定代理对象，而动态代理实在运行时，通过反射机制实现动态代理，并且能够代理多种类型的对象。</p><h1 id="动态代理实现"><a href="#动态代理实现" class="headerlink" title="动态代理实现"></a>动态代理实现</h1><h2 id="JDK自带实现"><a href="#JDK自带实现" class="headerlink" title="JDK自带实现"></a>JDK自带实现</h2><p>动态代理类使用字节码动态生成加载技术，在运行时生成加载类。其中JDK自带实现动态代理功能，但功能较弱，只能生成同一个接口的代理类。下面对上面的实例进行改造：</p><p><strong>动态代理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> ISubject realObject; <span class="comment">//定义主题接口</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//如果第一次调用，生成真实对象</span></span><br><span class="line">        <span class="keyword">if</span>(realObject == <span class="keyword">null</span>)&#123;</span><br><span class="line">            realObject = <span class="keyword">new</span> RealObject();</span><br><span class="line">        &#125;</span><br><span class="line">         System.out.println(<span class="string">"ProxyObject do something!"</span>);</span><br><span class="line">        <span class="comment">// 返回真实对象完成实际的操作 </span></span><br><span class="line">         <span class="keyword">return</span> method.invoke(realObject, args);  </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面实现了Handler,类似于上面代理类中具体逻辑。</p><p><strong>生成动态代理对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bigdata.spitter.featch;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> ISubject realObject;<span class="comment">//定义主题接口</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//如果第一次调用，生成真实对象</span></span><br><span class="line">        <span class="keyword">if</span>(realObject == <span class="keyword">null</span>)&#123;</span><br><span class="line">            realObject = <span class="keyword">new</span> RealObject();</span><br><span class="line">        &#125;</span><br><span class="line">         System.out.println(<span class="string">"ProxyObject do something!"</span>);</span><br><span class="line">        <span class="comment">// 返回真实对象完成实际的操作 </span></span><br><span class="line">        <span class="comment">//  return realObject.doAction();</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(realObject, args);  </span><br><span class="line">&#125; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ISubject <span class="title">createProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ISubject proxy = (ISubject)Proxy.newProxyInstance(</span><br><span class="line">        ClassLoader.getSystemClassLoader(), <span class="keyword">new</span> Class[]&#123;ISubject.class&#125;, <span class="keyword">new</span> SubjectHandler());</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        SubjectHandler subjectHandler = <span class="keyword">new</span> SubjectHandler();  </span><br><span class="line">        ISubject proxy = (ISubject)subjectHandler.createProxy();  </span><br><span class="line">        proxy.doAction();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是基于JDK自带的动态代理实现方式，代理类逻辑由SubjectHandler，生成代理类后，由newProxyInstance()方法返回代理类的实例，一个动态代理就完成了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文讲述了代理模式、静态代理与动态代理的区别，还有基于JDK自带功能动态代理的实现。总而言之，代理就是屏蔽或隐藏真实对象的行为，避免暴露更多的对象信息，降低客户端使用真实对象的复杂度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在使用Java的过程中，逐渐开始了解设计模式，其中代理模式是其中比较简单的设计模式，日常工作中也经常接触到代理模式的使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="2018" scheme="https://cangqiong.github.io/categories/2018/"/>
    
      <category term="技术总结" scheme="https://cangqiong.github.io/categories/2018/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="设计模式" scheme="https://cangqiong.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Java" scheme="https://cangqiong.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>RESTful API介绍</title>
    <link href="https://cangqiong.github.io/2018/03/17/restful-api/"/>
    <id>https://cangqiong.github.io/2018/03/17/restful-api/</id>
    <published>2018-03-17T14:20:25.000Z</published>
    <updated>2018-03-17T15:47:20.673Z</updated>
    
    <content type="html"><![CDATA[<p>REST，刚接触这个词的时候，还以为是reset，后来又以为是rest(休息)，后来才知道它是英文“Representational State Transfer”的缩写，取其首字母得到REST。这段英文的翻译可以为“表现层状态转化”。它是Roy Thomas Fielding博士于2000年在他的博士论文中提出来的一种万维网软件架构风格。</p><h1 id="REST理解"><a href="#REST理解" class="headerlink" title="REST理解"></a>REST理解</h1><p>刚听这个词是不是很蒙，即使看了上面的介绍，是不是也觉得表现层状态转化是什么鬼？<br>那下面我进行详细解释<br>表现层（Representation）是指资源（Resources）的表现层。资源，其实就是网络上的可以认知的资源，比如文档、音乐、视频。可以通过URI(统一资源定位符)进行访问。</p><p>状态转化是指客户端与服务端的互动过程中，这必然涉及到数据与状态的变化。</p><p>RESET架构究竟是什么呢？</p><ol><li>每个URI标识互联网上的资源</li><li>连接是无状态的</li><li>客户端通过HTTP常用方法，对服务器端资源进行操作，实现”表现层状态转化”。</li></ol><h1 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h1><p>HTTP总共定义了八个方法，最常见的有4个，而设计RESTful接口的时候，应该遵循“安全性”与“幂等性”的要求</p><ul><li>安全性：无论请求多少次，都不会改变资源的状态。比如GET操作，无论执行多少遍，都不会改变资源的状态。所以对于GET类API，在编写应用端代码时，切记要尽可能避免出现删除或者更新数据的逻辑。</li><li>幂等性：无论是执行一次，还是执行多次，效果是等价的，比如 DELETE，PUT操作。以PUT操作为例，更新一次和更新多次，实际结果都是更新后的结果了。<br>具有安全性的方法：GET、HEAD、OPTIONS<br>具有幂等性的方法：GET、PUT、DELETE</li></ul><blockquote><p>GET(SELECT) -&gt; 查询操作,从服务器中取出资源<br>POST(CREATE) -&gt; 添加操作，在服务器新建资源<br>PUT(UPDATE) -&gt; 在服务器更新资源（客户端提供改变后的完整资源）。<br>PATCH(UPDATE) -&gt; 服务器更新资源（客户端提供改变的属性）<br>DELETE(DELETE) -&gt; 从服务器删除资源<br>另外两个不常用<br>HEAD -&gt; 获取资源的元数据。<br>OPTIONS -&gt; 获取信息，关于资源的哪些属性是客户端可以改变的。</p></blockquote><h1 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h1><p>REST是一种软件架构风格，并不是一种具体的标准。而在实际的后台开发过程中，逐渐变成面向接口进行开发，而为了让接口更加便于理解，更加规范，更加便于规范，业界逐渐开始采用REST风格。于是乎产生了具有REST风格的web API，而大家称之为RESTful API。</p><p>为了区分一般API与RESTful API,下面我先给出一个一般API，再给出RESTful API。</p><blockquote><p>POST <a href="http://localhost:8080/createUser" target="_blank" rel="noopener">http://localhost:8080/createUser</a><br>GET <a href="http://localhost:8080/getUser?id=123" target="_blank" rel="noopener">http://localhost:8080/getUser?id=123</a></p></blockquote><p>看完是不是觉得很熟悉，下面给出对应的RESTful 接口</p><blockquote><p>POST <a href="http://localhost:8080/users" target="_blank" rel="noopener">http://localhost:8080/users</a><br>GET <a href="http://localhost:8080/users/123" target="_blank" rel="noopener">http://localhost:8080/users/123</a></p></blockquote><h1 id="RESTful-API-常见设计错误"><a href="#RESTful-API-常见设计错误" class="headerlink" title="RESTful API 常见设计错误"></a>RESTful API 常见设计错误</h1><p><strong>URI包含动词。</strong>这是最常见的错误。RESTful 接口应该是采用对应的HTTP动词作为操作，而后面的URL链接标识具体的资源，它表示资源的状态转移。”资源”表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中。<br>举例来说，某个URI是/users/show/1，其中show是动词，这个URI就设计错了，正确的写法应该是/posts/1，然后用GET方法表示show。</p><p><strong>使用名词单数</strong><br>为了不混淆名词的单复数。保持简单，只用复数名词定义所有资源。<br>/cars 代替 /car<br>/users 代替 /user<br>/products 代替 /product<br>/settings 代替 /settings</p><p><strong>名词使用驼峰模式或眼镜蛇模式</strong>。资源名称应该尽量采用小写或使用”-“进行连接<br>/product-name 代替 /productName</p><h1 id="RESTful-API具体实例"><a href="#RESTful-API具体实例" class="headerlink" title="RESTful API具体实例"></a>RESTful API具体实例</h1><p>RESTful API常见路径为：<strong>/版本/模块/资源/{标识}/集合</strong>。<br>下面是具体样例</p><blockquote><p>/user/{uid}/frends -&gt; 好友列表<br>/user/{uid}/followers -&gt; 关注列表<br>GET /tickets # 获取ticket列表<br>GET /tickets/12 # 查看某个具体的ticket<br>POST /tickets # 新建一个ticket<br>PUT /tickets/12 # 更新ticket 12.<br>DELETE /tickets/12 #删除ticekt 12  </p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实RESTful API就是采用REST架构风格的API，便于理解与规范开发。而REST架构风格就是使用HTTP名词作为操作，而操作的对象是URL对应的资源。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;REST，刚接触这个词的时候，还以为是reset，后来又以为是rest(休息)，后来才知道它是英文“Representational State Transfer”的缩写，取其首字母得到REST。这段英文的翻译可以为“表现层状态转化”。它是Roy Thomas Fieldi
      
    
    </summary>
    
      <category term="2018" scheme="https://cangqiong.github.io/categories/2018/"/>
    
      <category term="技术总结" scheme="https://cangqiong.github.io/categories/2018/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="api" scheme="https://cangqiong.github.io/tags/api/"/>
    
  </entry>
  
  <entry>
    <title>Open api安全设计与实现</title>
    <link href="https://cangqiong.github.io/2018/03/11/open-api-security/"/>
    <id>https://cangqiong.github.io/2018/03/11/open-api-security/</id>
    <published>2018-03-11T12:50:25.000Z</published>
    <updated>2018-03-17T10:53:24.014Z</updated>
    
    <content type="html"><![CDATA[<p>随着微服务架构的盛行及前后端的分离，后端开发逐渐转向开发独立的接口。接口一般给前端或者内部调用，一般来说是可以说是安全的。但如果要将接口暴露给第三方的话，会产生很多安全隐患。本文针对一些对外暴露的接口，即Open API，如何保证其安全，基于网上的资料，设计了一个Open API的安全加密方案，并给出了原型实现。</p><h2 id="接口安全标准"><a href="#接口安全标准" class="headerlink" title="接口安全标准"></a>接口安全标准</h2><ol><li>有调用者身份</li><li>请求的唯一性</li><li>请求的参数不能被篡改</li><li>请求的有效时间</li></ol><h2 id="接口安全实现原理"><a href="#接口安全实现原理" class="headerlink" title="接口安全实现原理"></a>接口安全实现原理</h2><p>要保证接口安全地对外暴露，基于上面的安全标准，一般来说采用对接口参数进行加密签名，或者基于OAuth2的认证进行保证接口安全。</p><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><p>结合网上的实现方式，本文做了以下设计</p><p>对于第三方或者外部系统调用内部API时，必须对请求参数进行签名加密，并且还要传入Token进行认证，为了保证请求的有效时间还加入时间戳。Token可以确保接口安全标准的1与2两点，而对请求参数加密能保证请求参数不能被篡改。相信这样的实现能够确保一般的Open API的安全性。<br>具体时序图如下所示：<br> <img src="https://raw.githubusercontent.com/cangqiong/blog-web/master/images/API签名加密.png" alt="image"></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><ol><li>第三方从内部系统获取Token</li><li>对除签名外的所有请求参数按key做的升序排列。例如：有c=3,b=2,a=1三个参，另加上时间戳后,按key排序后为：a=1，b=2，c=3,timestamp=12345678。</li><li>把参数名和参数值连接成字符串，得到拼装字符：a1b2c3_timestamp12345678</li><li>用获取到的Token对请求上面的拼接字符串进行加密，MD5或DES均可。</li><li>将该请求参数一起发过去后，被调用端基于对时间戳的有效性与Token的有效性，与签名的正确性进行判断，从而能够保证API的安全。</li></ol><p>PS： 被调用方在验证对应的请求参数之前，还可以对请求的API进行判断，看是否在开放白名单中，用户是否有访问该API的权限。</p><h2 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h2><p>如何获取如下的带签名的URL呢：</p><blockquote><p><a href="http://localhost:8081/hello/sayHello?name=世界&amp;token=ec4f2d80e1e5f53fe77a5f1bc7ac1972&amp;timestamp=1520776118141&amp;appkey=1a9c3039af0d4bc1d08d6daaf9221fc7" target="_blank" rel="noopener">http://localhost:8081/hello/sayHello?name=世界&amp;token=ec4f2d80e1e5f53fe77a5f1bc7ac1972&amp;timestamp=1520776118141&amp;appkey=1a9c3039af0d4bc1d08d6daaf9221fc7</a></p></blockquote><p>初始的URL：<a href="http://localhost:8081/hello/sayHello?name=世界&amp;timestamp=1520776118141" target="_blank" rel="noopener">http://localhost:8081/hello/sayHello?name=世界&amp;timestamp=1520776118141</a><br>请求Token方式略过不提。<br>通过下面两个方法，将请求字符串进行排序，获取升序排序的字符串name世界timestamp152077611814<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">getUrlParams</span><span class="params">(String param)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (StringUtil.isEmptyOrNull(param)) &#123;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] params = param.split(<span class="string">"&amp;"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">        String[] p = params[i].split(<span class="string">"="</span>);</span><br><span class="line">        <span class="keyword">if</span> (p.length == <span class="number">2</span>) &#123;</span><br><span class="line">            map.put(p[<span class="number">0</span>], p[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getUrlParamsByMap</span><span class="params">(Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        sb.append(entry.getKey()).append(entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后基于Token进行加密，作为签名：appkey=1a9c3039af0d4bc1d08d6daaf9221fc7<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">md5Sign</span><span class="params">(String token, String originStr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DigestUtils.md5DigestAsHex((token + originStr).getBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后进行传输到被调用方进行验证<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!queryStrMap.containsKey(APPKEY) || !queryStrMap.containsKey(TOKEN) || !queryStrMap.containsKey(TIMESTAMP)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuinessException(SystemConstantEnum.REQUEEST_INVALID.getCode(), SystemConstantEnum.REQUEEST_INVALID.getMsg());</span><br><span class="line">&#125;</span><br><span class="line">String token = queryStrMap.get(TOKEN).toString();</span><br><span class="line">String timeStamp = queryStrMap.get(TIMESTAMP).toString();</span><br><span class="line">String sign = queryStrMap.get(APPKEY).toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证该请求是否应失效</span></span><br><span class="line"><span class="keyword">long</span> requestTime = Long.parseLong(timeStamp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> diffTime = System.currentTimeMillis() - requestTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (diffTime &lt; <span class="number">0</span> || diffTime &gt; maxDiffTime) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuinessException(SystemConstantEnum.REQUEEST_INVALID.getCode(), SystemConstantEnum.REQUEEST_INVALID.getMsg());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证Token是否存在且有效</span></span><br><span class="line"><span class="keyword">if</span> (TokenUtil.getUiid(token) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuinessException(SystemConstantEnum.TOKEN_INVALID.getCode(), SystemConstantEnum.TOKEN_INVALID.getMsg());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断该接口是否开放</span></span><br><span class="line">ApiBlankList apiBlankList = <span class="keyword">new</span> ApiBlankList();</span><br><span class="line">String apiPath = requestMethod + <span class="string">" "</span> + requestUri;</span><br><span class="line">apiBlankList.setApi(apiPath);</span><br><span class="line">List&lt;ApiBlankList&gt; apiBlankListList = apiBlankListMapper.select(apiBlankList);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (CollectionUtils.isEmpty(apiBlankListList)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuinessException(SystemConstantEnum.API_REFUSE_ACCESS.getCode(), SystemConstantEnum.API_REFUSE_ACCESS.getMsg());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断该用户是否有权限访问该接口</span></span><br><span class="line">String uiid = TokenUtil.getUiid(token);</span><br><span class="line">UserApi userApi = <span class="keyword">new</span> UserApi();</span><br><span class="line">userApi.setApiPath(apiPath);</span><br><span class="line">userApi.setUiid(uiid);</span><br><span class="line">List&lt;UserApi&gt; userApis = userApiMapper.select(userApi);</span><br><span class="line"><span class="keyword">if</span> (CollectionUtils.isEmpty(userApis)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuinessException(SystemConstantEnum.API_REFUSE_ACCESS.getCode(), SystemConstantEnum.API_REFUSE_ACCESS.getMsg());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证签名是否正确</span></span><br><span class="line">String signStr = getSign(queryString);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!sign.equals(signStr)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuinessException(SystemConstantEnum.SIGN_NOT_CORRECT.getCode(), SystemConstantEnum.SIGN_NOT_CORRECT.getMsg());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是本文提出的基于Token与签名结合的安全设计与代码实现。如有不足之处，请发邮件告知或在github上提issue。<br>github地址：<a href="https://github.com/cangqiong/open-api-security" target="_blank" rel="noopener">open-api-security</a></p><p>参考文章：<br><a href="https://www.cnblogs.com/codeon/p/5900914.html?from=timeline&amp;isappinstalled=0" target="_blank" rel="noopener">如何写出安全的API接口？接口参数加密签名设计思路</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着微服务架构的盛行及前后端的分离，后端开发逐渐转向开发独立的接口。接口一般给前端或者内部调用，一般来说是可以说是安全的。但如果要将接口暴露给第三方的话，会产生很多安全隐患。本文针对一些对外暴露的接口，即Open API，如何保证其安全，基于网上的资料，设计了一个Open 
      
    
    </summary>
    
      <category term="2018" scheme="https://cangqiong.github.io/categories/2018/"/>
    
      <category term="设计" scheme="https://cangqiong.github.io/categories/2018/%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="Open api" scheme="https://cangqiong.github.io/tags/Open-api/"/>
    
      <category term="源码实现" scheme="https://cangqiong.github.io/tags/%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
</feed>
