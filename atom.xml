<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chason&#39;s Blog.渺沧海之一粟</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cangqiong.github.io/"/>
  <updated>2018-03-11T14:06:28.533Z</updated>
  <id>https://cangqiong.github.io/</id>
  
  <author>
    <name>Chason</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Open api安全设计与实现</title>
    <link href="https://cangqiong.github.io/2018/03/11/open-api-security/"/>
    <id>https://cangqiong.github.io/2018/03/11/open-api-security/</id>
    <published>2018-03-11T12:50:25.000Z</published>
    <updated>2018-03-11T14:06:28.533Z</updated>
    
    <content type="html"><![CDATA[<p>随着微服务架构的盛行及前后端的分离，后端开发逐渐转向开发独立的接口。接口一般给前端或者内部调用，一般来说是可以说是安全的。但如果要将接口暴露给第三方的话，会产生很多安全隐患。本文针对一些对外暴露的接口，即Open API，如何保证其安全，基于网上的资料，设计了一个Open API的安全加密方案，并给出了原型实现。</p><h2 id="接口安全标准"><a href="#接口安全标准" class="headerlink" title="接口安全标准"></a>接口安全标准</h2><ol><li>有调用者身份</li><li>请求的唯一性</li><li>请求的参数不能被篡改</li><li>请求的有效时间</li></ol><h2 id="接口安全实现原理"><a href="#接口安全实现原理" class="headerlink" title="接口安全实现原理"></a>接口安全实现原理</h2><p>要保证接口安全地对外暴露，基于上面的安全标准，一般来说采用对接口参数进行加密签名，或者基于OAuth2的认证进行保证接口安全。</p><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><p>结合网上的实现方式，本文做了以下设计</p><p>对于第三方或者外部系统调用内部API时，必须对请求参数进行签名加密，并且还要传入Token进行认证，为了保证请求的有效时间还加入时间戳。Token可以确保接口安全标准的1与2两点，而对请求参数加密能保证请求参数不能被篡改。相信这样的实现能够确保一般的Open API的安全性。<br>具体时序图如下所示：<br> <img src="https://raw.githubusercontent.com/cangqiong/blog-web/master/images/API签名加密.png" alt="image"></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><ol><li>第三方从内部系统获取Token</li><li>对除签名外的所有请求参数按key做的升序排列。例如：有c=3,b=2,a=1三个参，另加上时间戳后,按key排序后为：a=1，b=2，c=3,timestamp=12345678。</li><li>把参数名和参数值连接成字符串，得到拼装字符：a1b2c3_timestamp12345678</li><li>用获取到的Token对请求上面的拼接字符串进行加密，MD5或DES均可。</li><li>将该请求参数一起发过去后，被调用端基于对时间戳的有效性与Token的有效性，与签名的正确性进行判断，从而能够保证API的安全。</li></ol><p>PS： 被调用方在验证对应的请求参数之前，还可以对请求的API进行判断，看是否在开放白名单中，用户是否有访问该API的权限。</p><h2 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h2><p>如何获取如下的带签名的URL呢：</p><blockquote><p><a href="http://localhost:8081/hello/sayHello?name=世界&amp;token=ec4f2d80e1e5f53fe77a5f1bc7ac1972&amp;timestamp=1520776118141&amp;appkey=1a9c3039af0d4bc1d08d6daaf9221fc7" target="_blank" rel="noopener">http://localhost:8081/hello/sayHello?name=世界&amp;token=ec4f2d80e1e5f53fe77a5f1bc7ac1972&amp;timestamp=1520776118141&amp;appkey=1a9c3039af0d4bc1d08d6daaf9221fc7</a></p></blockquote><p>初始的URL：<a href="http://localhost:8081/hello/sayHello?name=世界&amp;timestamp=1520776118141" target="_blank" rel="noopener">http://localhost:8081/hello/sayHello?name=世界&amp;timestamp=1520776118141</a><br>请求Token方式略过不提。<br>通过下面两个方法，将请求字符串进行排序，获取升序排序的字符串name世界timestamp152077611814<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">getUrlParams</span><span class="params">(String param)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (StringUtil.isEmptyOrNull(param)) &#123;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] params = param.split(<span class="string">"&amp;"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">        String[] p = params[i].split(<span class="string">"="</span>);</span><br><span class="line">        <span class="keyword">if</span> (p.length == <span class="number">2</span>) &#123;</span><br><span class="line">            map.put(p[<span class="number">0</span>], p[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getUrlParamsByMap</span><span class="params">(Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        sb.append(entry.getKey()).append(entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后基于Token进行加密，作为签名：appkey=1a9c3039af0d4bc1d08d6daaf9221fc7<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">md5Sign</span><span class="params">(String token, String originStr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DigestUtils.md5DigestAsHex((token + originStr).getBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后进行传输到被调用方进行验证<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!queryStrMap.containsKey(APPKEY) || !queryStrMap.containsKey(TOKEN) || !queryStrMap.containsKey(TIMESTAMP)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuinessException(SystemConstantEnum.REQUEEST_INVALID.getCode(), SystemConstantEnum.REQUEEST_INVALID.getMsg());</span><br><span class="line">&#125;</span><br><span class="line">String token = queryStrMap.get(TOKEN).toString();</span><br><span class="line">String timeStamp = queryStrMap.get(TIMESTAMP).toString();</span><br><span class="line">String sign = queryStrMap.get(APPKEY).toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证该请求是否应失效</span></span><br><span class="line"><span class="keyword">long</span> requestTime = Long.parseLong(timeStamp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> diffTime = System.currentTimeMillis() - requestTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (diffTime &lt; <span class="number">0</span> || diffTime &gt; maxDiffTime) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuinessException(SystemConstantEnum.REQUEEST_INVALID.getCode(), SystemConstantEnum.REQUEEST_INVALID.getMsg());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证Token是否存在且有效</span></span><br><span class="line"><span class="keyword">if</span> (TokenUtil.getUiid(token) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuinessException(SystemConstantEnum.TOKEN_INVALID.getCode(), SystemConstantEnum.TOKEN_INVALID.getMsg());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断该接口是否开放</span></span><br><span class="line">ApiBlankList apiBlankList = <span class="keyword">new</span> ApiBlankList();</span><br><span class="line">String apiPath = requestMethod + <span class="string">" "</span> + requestUri;</span><br><span class="line">apiBlankList.setApi(apiPath);</span><br><span class="line">List&lt;ApiBlankList&gt; apiBlankListList = apiBlankListMapper.select(apiBlankList);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (CollectionUtils.isEmpty(apiBlankListList)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuinessException(SystemConstantEnum.API_REFUSE_ACCESS.getCode(), SystemConstantEnum.API_REFUSE_ACCESS.getMsg());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断该用户是否有权限访问该接口</span></span><br><span class="line">String uiid = TokenUtil.getUiid(token);</span><br><span class="line">UserApi userApi = <span class="keyword">new</span> UserApi();</span><br><span class="line">userApi.setApiPath(apiPath);</span><br><span class="line">userApi.setUiid(uiid);</span><br><span class="line">List&lt;UserApi&gt; userApis = userApiMapper.select(userApi);</span><br><span class="line"><span class="keyword">if</span> (CollectionUtils.isEmpty(userApis)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuinessException(SystemConstantEnum.API_REFUSE_ACCESS.getCode(), SystemConstantEnum.API_REFUSE_ACCESS.getMsg());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证签名是否正确</span></span><br><span class="line">String signStr = getSign(queryString);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!sign.equals(signStr)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuinessException(SystemConstantEnum.SIGN_NOT_CORRECT.getCode(), SystemConstantEnum.SIGN_NOT_CORRECT.getMsg());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是本文提出的基于Token与签名结合的安全设计与代码实现。如有不足之处，请发邮件告知或在github上提issue。<br>github地址：<a href="https://github.com/cangqiong/open-api-security" target="_blank" rel="noopener">open-api-security</a></p><p>参考文章：<br><a href="https://www.cnblogs.com/codeon/p/5900914.html?from=timeline&amp;isappinstalled=0" target="_blank" rel="noopener">如何写出安全的API接口？接口参数加密签名设计思路</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着微服务架构的盛行及前后端的分离，后端开发逐渐转向开发独立的接口。接口一般给前端或者内部调用，一般来说是可以说是安全的。但如果要将接口暴露给第三方的话，会产生很多安全隐患。本文针对一些对外暴露的接口，即Open API，如何保证其安全，基于网上的资料，设计了一个Open 
      
    
    </summary>
    
      <category term="2018" scheme="https://cangqiong.github.io/categories/2018/"/>
    
      <category term="设计" scheme="https://cangqiong.github.io/categories/2018/%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="Open api" scheme="https://cangqiong.github.io/tags/Open-api/"/>
    
      <category term="源码实现" scheme="https://cangqiong.github.io/tags/%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
</feed>
