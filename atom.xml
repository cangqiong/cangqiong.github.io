<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chason&#39;s Blog.渺沧海之一粟</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cangqiong.github.io/"/>
  <updated>2018-03-17T15:47:20.673Z</updated>
  <id>https://cangqiong.github.io/</id>
  
  <author>
    <name>Chason</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RESTful API介绍</title>
    <link href="https://cangqiong.github.io/2018/03/17/restful-api/"/>
    <id>https://cangqiong.github.io/2018/03/17/restful-api/</id>
    <published>2018-03-17T14:20:25.000Z</published>
    <updated>2018-03-17T15:47:20.673Z</updated>
    
    <content type="html"><![CDATA[<p>REST，刚接触这个词的时候，还以为是reset，后来又以为是rest(休息)，后来才知道它是英文“Representational State Transfer”的缩写，取其首字母得到REST。这段英文的翻译可以为“表现层状态转化”。它是Roy Thomas Fielding博士于2000年在他的博士论文中提出来的一种万维网软件架构风格。</p><h1 id="REST理解"><a href="#REST理解" class="headerlink" title="REST理解"></a>REST理解</h1><p>刚听这个词是不是很蒙，即使看了上面的介绍，是不是也觉得表现层状态转化是什么鬼？<br>那下面我进行详细解释<br>表现层（Representation）是指资源（Resources）的表现层。资源，其实就是网络上的可以认知的资源，比如文档、音乐、视频。可以通过URI(统一资源定位符)进行访问。</p><p>状态转化是指客户端与服务端的互动过程中，这必然涉及到数据与状态的变化。</p><p>RESET架构究竟是什么呢？</p><ol><li>每个URI标识互联网上的资源</li><li>连接是无状态的</li><li>客户端通过HTTP常用方法，对服务器端资源进行操作，实现”表现层状态转化”。</li></ol><h1 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h1><p>HTTP总共定义了八个方法，最常见的有4个，而设计RESTful接口的时候，应该遵循“安全性”与“幂等性”的要求</p><ul><li>安全性：无论请求多少次，都不会改变资源的状态。比如GET操作，无论执行多少遍，都不会改变资源的状态。所以对于GET类API，在编写应用端代码时，切记要尽可能避免出现删除或者更新数据的逻辑。</li><li>幂等性：无论是执行一次，还是执行多次，效果是等价的，比如 DELETE，PUT操作。以PUT操作为例，更新一次和更新多次，实际结果都是更新后的结果了。<br>具有安全性的方法：GET、HEAD、OPTIONS<br>具有幂等性的方法：GET、PUT、DELETE</li></ul><blockquote><p>GET(SELECT) -&gt; 查询操作,从服务器中取出资源<br>POST(CREATE) -&gt; 添加操作，在服务器新建资源<br>PUT(UPDATE) -&gt; 在服务器更新资源（客户端提供改变后的完整资源）。<br>PATCH(UPDATE) -&gt; 服务器更新资源（客户端提供改变的属性）<br>DELETE(DELETE) -&gt; 从服务器删除资源<br>另外两个不常用<br>HEAD -&gt; 获取资源的元数据。<br>OPTIONS -&gt; 获取信息，关于资源的哪些属性是客户端可以改变的。</p></blockquote><h1 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h1><p>REST是一种软件架构风格，并不是一种具体的标准。而在实际的后台开发过程中，逐渐变成面向接口进行开发，而为了让接口更加便于理解，更加规范，更加便于规范，业界逐渐开始采用REST风格。于是乎产生了具有REST风格的web API，而大家称之为RESTful API。</p><p>为了区分一般API与RESTful API,下面我先给出一个一般API，再给出RESTful API。</p><blockquote><p>POST <a href="http://localhost:8080/createUser" target="_blank" rel="noopener">http://localhost:8080/createUser</a><br>GET <a href="http://localhost:8080/getUser?id=123" target="_blank" rel="noopener">http://localhost:8080/getUser?id=123</a></p></blockquote><p>看完是不是觉得很熟悉，下面给出对应的RESTful 接口</p><blockquote><p>POST <a href="http://localhost:8080/users" target="_blank" rel="noopener">http://localhost:8080/users</a><br>GET <a href="http://localhost:8080/users/123" target="_blank" rel="noopener">http://localhost:8080/users/123</a></p></blockquote><h1 id="RESTful-API-常见设计错误"><a href="#RESTful-API-常见设计错误" class="headerlink" title="RESTful API 常见设计错误"></a>RESTful API 常见设计错误</h1><p><strong>URI包含动词。</strong>这是最常见的错误。RESTful 接口应该是采用对应的HTTP动词作为操作，而后面的URL链接标识具体的资源，它表示资源的状态转移。”资源”表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中。<br>举例来说，某个URI是/users/show/1，其中show是动词，这个URI就设计错了，正确的写法应该是/posts/1，然后用GET方法表示show。</p><p><strong>使用名词单数</strong><br>为了不混淆名词的单复数。保持简单，只用复数名词定义所有资源。<br>/cars 代替 /car<br>/users 代替 /user<br>/products 代替 /product<br>/settings 代替 /settings</p><p><strong>名词使用驼峰模式或眼镜蛇模式</strong>。资源名称应该尽量采用小写或使用”-“进行连接<br>/product-name 代替 /productName</p><h1 id="RESTful-API具体实例"><a href="#RESTful-API具体实例" class="headerlink" title="RESTful API具体实例"></a>RESTful API具体实例</h1><p>RESTful API常见路径为：<strong>/版本/模块/资源/{标识}/集合</strong>。<br>下面是具体样例</p><blockquote><p>/user/{uid}/frends -&gt; 好友列表<br>/user/{uid}/followers -&gt; 关注列表<br>GET /tickets # 获取ticket列表<br>GET /tickets/12 # 查看某个具体的ticket<br>POST /tickets # 新建一个ticket<br>PUT /tickets/12 # 更新ticket 12.<br>DELETE /tickets/12 #删除ticekt 12  </p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实RESTful API就是采用REST架构风格的API，便于理解与规范开发。而REST架构风格就是使用HTTP名词作为操作，而操作的对象是URL对应的资源。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;REST，刚接触这个词的时候，还以为是reset，后来又以为是rest(休息)，后来才知道它是英文“Representational State Transfer”的缩写，取其首字母得到REST。这段英文的翻译可以为“表现层状态转化”。它是Roy Thomas Fieldi
      
    
    </summary>
    
      <category term="2018" scheme="https://cangqiong.github.io/categories/2018/"/>
    
      <category term="技术总结" scheme="https://cangqiong.github.io/categories/2018/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="api" scheme="https://cangqiong.github.io/tags/api/"/>
    
  </entry>
  
  <entry>
    <title>Open api安全设计与实现</title>
    <link href="https://cangqiong.github.io/2018/03/11/open-api-security/"/>
    <id>https://cangqiong.github.io/2018/03/11/open-api-security/</id>
    <published>2018-03-11T12:50:25.000Z</published>
    <updated>2018-03-17T10:53:24.014Z</updated>
    
    <content type="html"><![CDATA[<p>随着微服务架构的盛行及前后端的分离，后端开发逐渐转向开发独立的接口。接口一般给前端或者内部调用，一般来说是可以说是安全的。但如果要将接口暴露给第三方的话，会产生很多安全隐患。本文针对一些对外暴露的接口，即Open API，如何保证其安全，基于网上的资料，设计了一个Open API的安全加密方案，并给出了原型实现。</p><h2 id="接口安全标准"><a href="#接口安全标准" class="headerlink" title="接口安全标准"></a>接口安全标准</h2><ol><li>有调用者身份</li><li>请求的唯一性</li><li>请求的参数不能被篡改</li><li>请求的有效时间</li></ol><h2 id="接口安全实现原理"><a href="#接口安全实现原理" class="headerlink" title="接口安全实现原理"></a>接口安全实现原理</h2><p>要保证接口安全地对外暴露，基于上面的安全标准，一般来说采用对接口参数进行加密签名，或者基于OAuth2的认证进行保证接口安全。</p><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><p>结合网上的实现方式，本文做了以下设计</p><p>对于第三方或者外部系统调用内部API时，必须对请求参数进行签名加密，并且还要传入Token进行认证，为了保证请求的有效时间还加入时间戳。Token可以确保接口安全标准的1与2两点，而对请求参数加密能保证请求参数不能被篡改。相信这样的实现能够确保一般的Open API的安全性。<br>具体时序图如下所示：<br> <img src="https://raw.githubusercontent.com/cangqiong/blog-web/master/images/API签名加密.png" alt="image"></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><ol><li>第三方从内部系统获取Token</li><li>对除签名外的所有请求参数按key做的升序排列。例如：有c=3,b=2,a=1三个参，另加上时间戳后,按key排序后为：a=1，b=2，c=3,timestamp=12345678。</li><li>把参数名和参数值连接成字符串，得到拼装字符：a1b2c3_timestamp12345678</li><li>用获取到的Token对请求上面的拼接字符串进行加密，MD5或DES均可。</li><li>将该请求参数一起发过去后，被调用端基于对时间戳的有效性与Token的有效性，与签名的正确性进行判断，从而能够保证API的安全。</li></ol><p>PS： 被调用方在验证对应的请求参数之前，还可以对请求的API进行判断，看是否在开放白名单中，用户是否有访问该API的权限。</p><h2 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h2><p>如何获取如下的带签名的URL呢：</p><blockquote><p><a href="http://localhost:8081/hello/sayHello?name=世界&amp;token=ec4f2d80e1e5f53fe77a5f1bc7ac1972&amp;timestamp=1520776118141&amp;appkey=1a9c3039af0d4bc1d08d6daaf9221fc7" target="_blank" rel="noopener">http://localhost:8081/hello/sayHello?name=世界&amp;token=ec4f2d80e1e5f53fe77a5f1bc7ac1972&amp;timestamp=1520776118141&amp;appkey=1a9c3039af0d4bc1d08d6daaf9221fc7</a></p></blockquote><p>初始的URL：<a href="http://localhost:8081/hello/sayHello?name=世界&amp;timestamp=1520776118141" target="_blank" rel="noopener">http://localhost:8081/hello/sayHello?name=世界&amp;timestamp=1520776118141</a><br>请求Token方式略过不提。<br>通过下面两个方法，将请求字符串进行排序，获取升序排序的字符串name世界timestamp152077611814<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">getUrlParams</span><span class="params">(String param)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (StringUtil.isEmptyOrNull(param)) &#123;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] params = param.split(<span class="string">"&amp;"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">        String[] p = params[i].split(<span class="string">"="</span>);</span><br><span class="line">        <span class="keyword">if</span> (p.length == <span class="number">2</span>) &#123;</span><br><span class="line">            map.put(p[<span class="number">0</span>], p[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getUrlParamsByMap</span><span class="params">(Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        sb.append(entry.getKey()).append(entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后基于Token进行加密，作为签名：appkey=1a9c3039af0d4bc1d08d6daaf9221fc7<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">md5Sign</span><span class="params">(String token, String originStr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DigestUtils.md5DigestAsHex((token + originStr).getBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后进行传输到被调用方进行验证<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!queryStrMap.containsKey(APPKEY) || !queryStrMap.containsKey(TOKEN) || !queryStrMap.containsKey(TIMESTAMP)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuinessException(SystemConstantEnum.REQUEEST_INVALID.getCode(), SystemConstantEnum.REQUEEST_INVALID.getMsg());</span><br><span class="line">&#125;</span><br><span class="line">String token = queryStrMap.get(TOKEN).toString();</span><br><span class="line">String timeStamp = queryStrMap.get(TIMESTAMP).toString();</span><br><span class="line">String sign = queryStrMap.get(APPKEY).toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证该请求是否应失效</span></span><br><span class="line"><span class="keyword">long</span> requestTime = Long.parseLong(timeStamp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> diffTime = System.currentTimeMillis() - requestTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (diffTime &lt; <span class="number">0</span> || diffTime &gt; maxDiffTime) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuinessException(SystemConstantEnum.REQUEEST_INVALID.getCode(), SystemConstantEnum.REQUEEST_INVALID.getMsg());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证Token是否存在且有效</span></span><br><span class="line"><span class="keyword">if</span> (TokenUtil.getUiid(token) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuinessException(SystemConstantEnum.TOKEN_INVALID.getCode(), SystemConstantEnum.TOKEN_INVALID.getMsg());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断该接口是否开放</span></span><br><span class="line">ApiBlankList apiBlankList = <span class="keyword">new</span> ApiBlankList();</span><br><span class="line">String apiPath = requestMethod + <span class="string">" "</span> + requestUri;</span><br><span class="line">apiBlankList.setApi(apiPath);</span><br><span class="line">List&lt;ApiBlankList&gt; apiBlankListList = apiBlankListMapper.select(apiBlankList);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (CollectionUtils.isEmpty(apiBlankListList)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuinessException(SystemConstantEnum.API_REFUSE_ACCESS.getCode(), SystemConstantEnum.API_REFUSE_ACCESS.getMsg());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断该用户是否有权限访问该接口</span></span><br><span class="line">String uiid = TokenUtil.getUiid(token);</span><br><span class="line">UserApi userApi = <span class="keyword">new</span> UserApi();</span><br><span class="line">userApi.setApiPath(apiPath);</span><br><span class="line">userApi.setUiid(uiid);</span><br><span class="line">List&lt;UserApi&gt; userApis = userApiMapper.select(userApi);</span><br><span class="line"><span class="keyword">if</span> (CollectionUtils.isEmpty(userApis)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuinessException(SystemConstantEnum.API_REFUSE_ACCESS.getCode(), SystemConstantEnum.API_REFUSE_ACCESS.getMsg());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证签名是否正确</span></span><br><span class="line">String signStr = getSign(queryString);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!sign.equals(signStr)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuinessException(SystemConstantEnum.SIGN_NOT_CORRECT.getCode(), SystemConstantEnum.SIGN_NOT_CORRECT.getMsg());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是本文提出的基于Token与签名结合的安全设计与代码实现。如有不足之处，请发邮件告知或在github上提issue。<br>github地址：<a href="https://github.com/cangqiong/open-api-security" target="_blank" rel="noopener">open-api-security</a></p><p>参考文章：<br><a href="https://www.cnblogs.com/codeon/p/5900914.html?from=timeline&amp;isappinstalled=0" target="_blank" rel="noopener">如何写出安全的API接口？接口参数加密签名设计思路</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着微服务架构的盛行及前后端的分离，后端开发逐渐转向开发独立的接口。接口一般给前端或者内部调用，一般来说是可以说是安全的。但如果要将接口暴露给第三方的话，会产生很多安全隐患。本文针对一些对外暴露的接口，即Open API，如何保证其安全，基于网上的资料，设计了一个Open 
      
    
    </summary>
    
      <category term="2018" scheme="https://cangqiong.github.io/categories/2018/"/>
    
      <category term="设计" scheme="https://cangqiong.github.io/categories/2018/%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="Open api" scheme="https://cangqiong.github.io/tags/Open-api/"/>
    
      <category term="源码实现" scheme="https://cangqiong.github.io/tags/%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
</feed>
