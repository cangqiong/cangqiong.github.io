<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>MySQL原理</title>
      <link href="/2018/07/23/MySQL-theory/"/>
      <url>/2018/07/23/MySQL-theory/</url>
      <content type="html"><![CDATA[<h1 id="MySQL数据库介绍"><a href="#MySQL数据库介绍" class="headerlink" title="MySQL数据库介绍"></a>MySQL数据库介绍</h1><p>MySQL作为世界最流行的数据库，国内公司在经历去IOE之后，相信使用MySQL的公司相会更多。MySQL是一种一种小型关系型数据库，有体积小、速度快、可移植高、免费开源等优点。了解MySQL的其对应的核心原理到底是什么，对具体使用MySQL与优化有很大的帮助。因此本文介绍一下MySQL的底层原理，当然这只是MySQL的一小部分。</p><h1 id="数据库与索引"><a href="#数据库与索引" class="headerlink" title="数据库与索引"></a>数据库与索引</h1><blockquote><p>数据库其本质是采用<strong>一定方式</strong>存储能给多个用户共享、尽量少的冗余，与应用程序彼此独立的数据集合。</p></blockquote><p>一般而言，一定方式是指数据的组织方式，通常既包含逻辑结构，又包含存储对应的物理结构。逻辑结构包括关系型数据库（Relational database）与NoSQL，而传统数据库对应的存储的物理结构一般是采用B+Tree的形式进行存储。后面会介绍为什么采用B+Tree的存储数据。</p><p>传统的关系型数据库为了保证数据的持久性与可靠性，是将数据存储在磁盘中的。但基于磁盘存储有两大特性：</p><ol><li><p>磁盘IO性能非常底，严重影响数据库系统的性能。</p></li><li><p>磁盘顺序读写比随机读写的性能高很多。</p></li></ol><p>MySQL正是基于上面的两点特性与索引特性，对数据的组织方式进行不断优化，从而达到存取速度提升，提升性能的目标。</p><h1 id="从BST到B-Tree"><a href="#从BST到B-Tree" class="headerlink" title="从BST到B+Tree"></a>从BST到B+Tree</h1><p>那为什么传统数据库采用B+Tree的形式存储数据呢？</p><p>为了读取数据库中的数据，对数据进行全表搜索的话，必须对存储的数据结构进行优化，否则采用最原始的顺序存储的话，搜索的算法复杂度为O(n)，而且每读一条数据，就得进行磁盘IO一次，进行n次IO，相信这速度查询一次已经慢得可以先吃顿饭了。这显然太慢了，那怎么优化查找速度呢。</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>在多数情况下，我们发现并不需要匹配整行数据，而是只需要匹配某一个或几个列的值，这些用来确定或标识一条数据的列可以成为索引(<code>Index</code>)。<strong>索引实际上是一种存储数据中的特定列值的数据结构</strong>。<strong>索引本质是一种数据结构。</strong></p><p>索引可以类比书中的目录，目录是书中特定章节(列)的文字（值），目录指向页数，而索引指向数据存储的地址。读者可以通过目录快速找到自己想要的内容，我们可以通过索引快速定位到查找的数据。 当然如果要查找的数据不在索引中，那就相当于翻阅整本书来查找数据，也就是顺序扫描。</p><p>索引可以分为主键索引（Primary key）与辅助索引(Secondary key)，主键索引要求key是唯一的，而辅助索引的key可以重复，辅助索引可以有多个。</p><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>给数据建立索引后，那如何组织这些索引与数据呢？既然是为了查找数据，当然有人想到二叉搜索树（BST）</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014070402.png" alt="二叉搜索树"></p><p>二叉搜索树是一种搜索效率很高的数据结构，二叉搜索树在n个节点中找到目标之，一般只需要log(n)次比较：</p><blockquote><ol><li>每个节点最多有两个子树。</li><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树。</li></ol></blockquote><p>二叉搜索树在n个节点中找到目标之，一般只需要log(n)次比较，但二叉搜索树的结构不适合数据库，因为它的查找层次太高，极端情况下n个数据需要比较n次才能得到数据。如果有1万条数据的话，平均需要查找log(10000)=13次，这意味着要进行磁盘IO 13次，因为磁盘IO的速度远远大于数据处理的时间，查找效率还是太低。</p><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>B树是对二叉搜索树的改进，可以认为它是m叉的多路平衡查找树。它将相关数据尽量集中在一起，以便读取多个数据，减少硬盘操作次数。</p><p>B树的特性：</p><ol><li><p>任意非叶节点都最多只有M个儿子，且M&gt;2.</p></li><li><p>所有叶子结点都出现在同一层 。</p></li><li>子节点中的值，与父节点的值，有严格的大小对应关系。子节点的数量会比父节点的键值的数量大1，如下图所示，父节点有有2个键值，而子节点有3个节点，第一个子节点中值都小于7，第二个节点的值在7与16之间，第三个节点中的值大于16。</li></ol><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/65/B-tree.svg/400px-B-tree.svg.png" alt="img"> </p><p>一个Ｂ树通过约束所有叶子节点在相同深度来保持平衡。深度在元素添加至树的过程中缓慢增长，而整体深度极少地增长，B树就形成非常扁平的树了。这样采用B树存储的数据，读取磁盘的次数相对于二叉搜索树就大大减少了，从而提升了查询效率。</p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B树大大降低了搜索的层次，减少了磁盘IO次数，但当进行范围扫描时，还是需要不断进行中序遍历，于是产生了B树的变种：B+Tree。</p><p>B+Tree的特性：</p><ol><li><p>有n棵子树的非叶子结点中含有n个关键字（b树是n-1个），这些关键字不保存数据，只用来索引，所有数据都保存在叶子节点（b树是每个关键字都保存数据）。</p></li><li><p>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p></li><li><p>所有的非叶子结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</p></li><li><p>通常在b+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。</p><p><img src="http://img.mp.sohu.com/upload/20170713/358025867be14bb99bf8806b98e774d9_th.png" alt="B+树"> </p></li></ol><p>B+树的中间节点不保存数据，磁盘能容纳更多的节点，相比B树更扁平。对于范围查找，B+树只用遍历叶子节点链表。</p><h1 id="MySQL的核心架构"><a href="#MySQL的核心架构" class="headerlink" title="MySQL的核心架构"></a>MySQL的核心架构</h1><p>让我们现在了解一下MySQL的核心架构：</p><p><img src="https://upload-images.jianshu.io/upload_images/838913-fb7f263a0d00afe7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/583" alt="MySQL架构"> </p><p>MySQL的核心架构如上图所示，</p><ul><li>第一层：服务层为客户端的请求进行处理，包括连接管理、授权认证、安全等。 </li><li>第二层：MySQL核心服务层：主要提供，包括查询解析、分析、优化、缓存及所有内置函数（比如日期、时间、数学和加密），所有的跨存储引擎的功能都在这一层.</li><li>第三层：存储引擎层，负责数据的存储和提取。服务器通过Api与存储引擎进行通信，这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。</li></ul><h1 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h1><p>从上一节可以知道MySQL实际存储的数据是放在存储引擎这一层的，提到MySQL的存储引擎就不得不提到这两种存储引擎：<strong>MyISAM</strong>、<strong>InnoDB</strong>，MyISAM是不支持事务、也不支持外键，优势是访问速度快 ，是MySQL5.5.5之前版本默认的存储引擎，而InnoDB是现在最流行的MySQL存储引擎，因为它支持事务（ACID），支持行锁定和外键。</p><h2 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h2><p>聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。 </p><h2 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h2><p>每个MyISAM在磁盘上存储成3个文件，其中文件名和表名都相同，但是扩展名分别为：</p><ul><li>.frm(存储表定义)</li><li>MYD(MYData，存储数据)</li><li>MYI(MYIndex，存储索引</li></ul><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：</p><p><img src="http://www.muyesanren.com/wp-content/uploads/2017/05/img_592bcbde4d87d.png" alt="MyISAM主索引结构"> </p><p>在MyISAM中，主索引和辅助索引在结构上没有任何区别。</p><p><img src="http://www.muyesanren.com/wp-content/uploads/2017/05/img_592bcc3544dcd.png" alt="辅助索引结构"> </p><h2 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h2><p>而InnoDB在磁盘上存储成2个文件，其中文件名和表名都相同，但是扩展名分别为：</p><ul><li>.frm(存储表定义)</li><li>.ibd(InnoDB data，存储索引与数据)</li></ul><h3 id="聚集索引与非聚集索引"><a href="#聚集索引与非聚集索引" class="headerlink" title="聚集索引与非聚集索引"></a>聚集索引与非聚集索引</h3><blockquote><p>聚集索引的叶子节点就是数据节点，而非聚集索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。 </p></blockquote><p>InnoDB与MyISAM的第一个重大区别就是InnoDB的数据文件本身就InnoDB是采用聚簇索引，也就是InnoDB的数据文件本身就是索引文件。而MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p><p><img src="http://www.muyesanren.com/wp-content/uploads/2017/05/img_592bccb8a6b9e.png" alt="InnoDB主索引示意图"></p><p>上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p><p>第二个区别是与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data值。</p><p><img src="http://www.muyesanren.com/wp-content/uploads/2017/05/img_592bccf960c2a.png" alt="InnoDB辅助索引示意图"></p><p>聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p><p>为什么InnoDB没有像MyISAM一样直接指向数据行的物理地址呢？如果采用这种策略的话，每次对B+Tree节点进行分裂的时候，也就是物理地址发生改变的时候，二级索引需要全部重写。而InnoDB对二级索引之存储二级索引的列值和对应的主键值，它使得二级索引依赖主键索引的物理顺序，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。两者互有利弊, 权衡而视。</p><h1 id="InnoDB实际存储结构"><a href="#InnoDB实际存储结构" class="headerlink" title="InnoDB实际存储结构"></a>InnoDB实际存储结构</h1><p>Page是整个InnoDB存储的最基本构件，也是InnoDB磁盘管理的最小单位，与数据库相关的所有内容都存储在这种Page结构里。</p><ul><li><p>磁盘空间被划分为许多大小相同页(Page).(MySQL默认Page大小为16K)</p></li><li><p>一个表的这些数据块以链表的方式串联在一起。</p></li><li><p>数据是以行（Row）为单位一行一行的存放在磁盘上的块中,如图所示.</p></li><li><p>在访问数据时，一次从磁盘中读出或者写入至少一个完整的Page。</p></li></ul><p>Page页面存储格式如下图所示： </p><p><img src="http://images2015.cnblogs.com/blog/524341/201604/524341-20160416104952770-1354249661.jpg" alt="MySQL数据叶结构"> </p><p>  下面是InnoDB的表空间结构图： </p><p><img src="http://images2015.cnblogs.com/blog/524341/201604/524341-20160416104932379-1446683950.jpg" alt="表空间"> </p><p>PS：扇区是块设备的最小寻址单元，为512个字节，块是文件系统进行IO的最小单元，就是说，块是逻辑上的最小单元 ，一般为4K。</p><h1 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h1><p>从上面的内容可以看出索引对数据查找的重要性，所以提供两点建议：</p><ol><li>尽量采用索引进行查找，防止索引失效。</li><li>尽量使用自增自带作为主键，因为非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效。</li></ol>]]></content>
      
      <categories>
          
          <category> 2018 </category>
          
          <category> 技术总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DB </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在Linux服务器上定位问题</title>
      <link href="/2018/06/17/linux-and-location-problem/"/>
      <url>/2018/06/17/linux-and-location-problem/</url>
      <content type="html"><![CDATA[<blockquote><p>在后台应用中，承载后台应用的服务器基本都是Linux服务器，在后台应用的部署、运维、查错基本都要和Linux服务器打交道，这篇博客主要对工作中遇到的如何定位Linux服务器上的后台应用的出错进行总结：<strong>从哪些方面进行定位问题以及如何进行定位问题</strong>。</p></blockquote><h1 id="定位层次"><a href="#定位层次" class="headerlink" title="定位层次"></a>定位层次</h1><p>针对工作中后台应用遇到的问题，定位问题的层次可以分为两层：</p><ol><li>服务器层次；</li><li>应用层次；</li></ol><h2 id="服务器层次"><a href="#服务器层次" class="headerlink" title="服务器层次"></a>服务器层次</h2><p>顾名思义，服务器层次，就是说查看服务器自身的问题，服务器是否处于健康状态，就像你手机里的微信突然用不了，首先检查一下手机是否处于正常状态，能不能联网，内存是否足够，是不是卡住了。在服务器这个层面出错，就可能会导致部署在服务器上的后台无法正常工作。</p><p>那服务器的状态又可以分为好几个状态：</p><ol><li><p>CPU使用率</p><p>CPU使用率是指Linux服务器上CPU的使用比率，可以使用<code>top</code>命令查看当前的CPU使用率。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaocanghai ~]# top</span><br><span class="line">top - 20:47:42 up  7:02,  2 users,  load average: 0.00, 0.01, 0.05</span><br><span class="line">Tasks:  67 total,   1 running,  66 sleeping,   0 stopped,   0 zombie</span><br><span class="line"><span class="meta">%</span>Cpu(s):  0.3 us,  0.3 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  1883496 total,    89012 free,   768800 used,  1025684 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used.   915468 avail Mem</span><br></pre></td></tr></table></figure><p>如top命令执行效果，<code>%Cpu(s)</code>表示cpu使用率，<code>%us</code>：表示用户空间程序的cpu使用率，<code>%sy</code>：表示系统空间的cpu使用率，主要由内核程序使用。</p></li><li><p>内存状态</p><p>服务器的内存会决定应用的内存，从而影响后台应用的启动或执行速度。使用<code>free</code>可以查看当前系统的内存使用情况。<code>-m</code>表示以MB为单位表示显示内存情况</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaocanghai ~]<span class="comment"># free -m</span></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           1839         750          72           0        1016         894</span><br><span class="line">Swap:             0           0           0</span><br></pre></td></tr></table></figure><p>第二行是内存的使用情况，total:内存总数，used：已经使用的内存数；free：空闲的内存数，buff/cache：被 buffer 和 cache 使用的物理内存大小 ，available：还可以被应用程序使用的物理内存大小。 </p></li><li><p>网络状态</p><p>服务器往往不是估计存在的，需要与其他服务器进行通信，所以网络状态也会影响服务器状态。一般网络的网络问题，可能是网络策略的问题。可以使用<code>ping</code>命令或<code>telnet</code>命令尝试访问其他服务器ip或者域名地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaocanghai ~]# ping baidu.com</span><br><span class="line">PING baidu.com (123.125.115.110) 56(84) bytes of data.</span><br><span class="line">64 bytes from 123.125.115.110 (123.125.115.110): icmp_seq=1 ttl=51 time=37.5 ms</span><br><span class="line">64 bytes from 123.125.115.110 (123.125.115.110): icmp_seq=2 ttl=51 time=37.6 ms</span><br><span class="line">64 bytes from 123.125.115.110 (123.125.115.110): icmp_seq=3 ttl=51 time=37.6 ms</span><br><span class="line">64 bytes from 123.125.115.110 (123.125.115.110): icmp_seq=4 ttl=51 time=37.6 ms</span><br><span class="line">--- baidu.com ping statistics ---</span><br><span class="line">4 packets transmitted, 4 received, 0% packet loss, time 3005ms</span><br><span class="line">rtt min/avg/max/mdev = 37.599/37.641/37.695/0.034 ms</span><br><span class="line">[root@xiaocanghai ~]# telnet baidu.com 80</span><br><span class="line">Trying 220.181.57.216...</span><br><span class="line">Connected to baidu.com.</span><br><span class="line">Escape character is '^]'.</span><br></pre></td></tr></table></figure><p>从上面执行命令来看，能够访问百度的网址。</p></li><li><p>硬盘状态</p><p>服务器往往会因为后台应用的增多，日志的迅速增加导致硬盘空间不够，从而导致应用无法正常执行。那采用<code>df</code>命令可以查看服务器的硬盘状态。加上<code>-h</code>是以可读性较高的方式进行显示服务器硬盘状态。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaocanghai ~]# df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/vda1        40G  5.4G   32G  15% /</span><br><span class="line">devtmpfs        911M     0  911M   0% /dev</span><br><span class="line">tmpfs           920M     0  920M   0% /dev/shm</span><br><span class="line">tmpfs           920M  328K  920M   1% /run</span><br><span class="line">tmpfs           920M     0  920M   0% /sys/fs/cgroup</span><br><span class="line">tmpfs           184M     0  184M   0% /run/user/0</span><br></pre></td></tr></table></figure><p>主要看<code>Use%</code>，看是否有接近90%的，如果有的话，说明得要开始清理磁盘了。</p></li><li><p>其他状态</p><p>服务器还有其他状态可能会影响应用的状态，比如日期，时区，文件的执行权限，</p><p>其实这里可以展开那就很多篇幅，下面列几个常有的命令吧。</p><ul><li><code>ls -ltr</code>按修改时间列出文件和文件夹详细信息 。使用这个命令能够看到文件的详细信息并且按修改时间顺序排序，可以清楚的看到最新修改文件的顺序。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-x.  2 root root  4096 Nov  5  2016 srv</span><br><span class="line">drwxr-xr-x.  2 root root  4096 Nov  5  2016 opt</span><br><span class="line">drwxr-xr-x.  2 root root  4096 Nov  5  2016 mnt</span><br><span class="line">drwxr-xr-x.  2 root root  4096 Nov  5  2016 media</span><br><span class="line">drwx------.  2 root root 16384 Aug 18  2017 lost+found</span><br><span class="line">lrwxrwxrwx.  1 root root     7 Aug 18  2017 bin -&gt; usr/bin</span><br><span class="line">lrwxrwxrwx.  1 root root     9 Aug 18  2017 lib64 -&gt; usr/lib64</span><br><span class="line">lrwxrwxrwx.  1 root root     7 Aug 18  2017 lib -&gt; usr/lib</span><br><span class="line">lrwxrwxrwx.  1 root root     8 Aug 18  2017 sbin -&gt; usr/sbin</span><br><span class="line">drwxr-xr-x. 13 root root  4096 Aug 18  2017 usr</span><br><span class="line">drwxr-xr-x.  3 root root  4096 Oct  4  2017 home</span><br><span class="line">drwxr-xr-x. 19 root root  4096 Oct  5  2017 var</span><br><span class="line">drwxr-xr-x   3 root root  4096 Oct 10  2017 cang</span><br><span class="line">drwxr-xr-x   3 root root  4096 Oct 22  2017 applog</span><br><span class="line">dr-xr-xr-x.  5 root root  4096 Nov 12  2017 boot</span><br><span class="line">drwxr-xr-x   4 root root  4096 Dec 18 23:02 appdata</span><br><span class="line">dr-xr-x---. 18 root root  4096 Apr 15 16:16 root</span><br><span class="line">drwxr-xr-x. 83 root root  4096 Jun 17 13:44 etc</span><br><span class="line">dr-xr-xr-x  81 root root     0 Jun 17 13:44 proc</span><br><span class="line">drwxr-xr-x  20 root root  3040 Jun 17 13:45 dev</span><br><span class="line">drwxr-xr-x  23 root root   660 Jun 17 21:17 run</span><br><span class="line">dr-xr-xr-x  13 root root     0 Jun 17 21:44 sys</span><br><span class="line">drwxrwxrwt. 20 root root  4096 Jun 17 22:47 tmp</span><br></pre></td></tr></table></figure><ul><li><p><code>date</code>查看当前系统时间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaocanghai /]# date  # 输出当前时间</span><br><span class="line">Sun Jun 17 22:54:46 CST 2018</span><br><span class="line">[root@xiaocanghai /]# date +"%Y-%m-%d %H:%m:%S" # 按指定格式输出当前时间</span><br><span class="line">2018-06-17 22:06:47</span><br><span class="line">[root@xiaocanghai /]# date +'%Z %z'  # 查看时区</span><br><span class="line">CST +0800</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="应用层次"><a href="#应用层次" class="headerlink" title="应用层次"></a>应用层次</h2><p>  从应用这个级别来定位出现的问题，又可以以应用状态进行区分进行查找问题。</p><p>  应用状态可以分为这几种：<strong>应用终止</strong>、<strong>应用假死</strong>、<strong>应用运行中</strong>。其中应用假死是应用运行中的一种特殊状态，进程没有终止，但访问没有反应，日志也没有输出，这种情况比较难定位问题。</p><p>  那如何知道应用处于什么状态呢？下面进行说明。</p><h3 id="如何定位应用状态"><a href="#如何定位应用状态" class="headerlink" title="如何定位应用状态"></a>如何定位应用状态</h3><p>  Linux定位服务器状态一般有以下几种方法：</p><h4 id="采用系统工具查看应用状态"><a href="#采用系统工具查看应用状态" class="headerlink" title="采用系统工具查看应用状态"></a>采用系统工具查看应用状态</h4><p>  1.<code>systemctl</code>或者<code>service</code>查看应用状态，命令格式：</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl  status &lt;app-name&gt;</span><br><span class="line">service &lt;app-name&gt; status</span><br></pre></td></tr></table></figure><p>  例子</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaocanghai /]# systemctl status nginx</span><br><span class="line">● nginx.service - nginx - high performance web server</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/nginx.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Sun 2018-06-17 15:20:04 CST; 7h ago</span><br><span class="line">     Docs: http://nginx.org/en/docs/</span><br><span class="line"> Main PID: 1994 (nginx)</span><br><span class="line">   CGroup: /system.slice/nginx.service</span><br><span class="line">           ├─1994 nginx: master process /usr/sbin/nginx -c /etc/nginx/nginx.conf</span><br><span class="line">           └─4226 nginx: worker process</span><br><span class="line"></span><br><span class="line">Jun 17 15:20:04 xiaocanghai systemd[1]: Starting nginx - high performance web server...</span><br><span class="line">Jun 17 15:20:04 xiaocanghai nginx[1990]: nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">Jun 17 15:20:04 xiaocanghai nginx[1990]: nginx: configuration file /etc/nginx/nginx.conf test is successful</span><br><span class="line">Jun 17 15:20:04 xiaocanghai systemd[1]: Failed to read PID from file /var/run/nginx.pid: Invalid argument</span><br><span class="line">Jun 17 15:20:04 xiaocanghai systemd[1]: Started nginx - high performance web server.</span><br></pre></td></tr></table></figure><ol start="2"><li><p><code>jps</code>。JVM自带的Java 进程查看工具可以查看正在运行的Java进程。</p></li><li><p><code>ps</code>。使用<code>jps</code>命令有时候不能准确地看到Java进程，这使用要采用<code>ps</code>命令了，其实<code>jps</code>相当于<code>ps</code>命令的Java定制版。<code>ps</code>更加强大能够查看服务器中所有进程状态。直接用<code>ps -ef</code>能够列出所有的进程，为了更加精确地定位进程，可以用<code>ps -ef | grep &lt;process-info&gt;</code>查找进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaocanghai /]# ps -ef | grep jenkins</span><br><span class="line">root      3044     1  0 16:25 ?        00:01:37 java -jar jenkins.war --httpPort=8091</span><br><span class="line">root      9435  8904  0 23:21 pts/2    00:00:00 grep --color=auto jenkins</span><br></pre></td></tr></table></figure><ol start="4"><li><p><code>netstat -tunlp | grep &lt;port&gt;</code>。有时候可能只知道应用的端口，想查看该应用状态，可以用netstat命令进行查看。可以查到对应应用的PID与应用名称</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaocanghai /]# netstat -tunlp | grep 22</span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1428/sshd</span><br></pre></td></tr></table></figure></li></ol></li></ol><h4 id="进一步判断应用状态"><a href="#进一步判断应用状态" class="headerlink" title="进一步判断应用状态"></a>进一步判断应用状态</h4><p>使用系统自带的命令可以知道进程有没有在执行，但进程在执行，仍有可能处于假死状态，如何判断应用的真实状态呢？想知道应用有没有在正常运行，直接访问一下应用，看日志，看返回结果，这是最常用也是最有效的方法。</p><h5 id="模拟访问应用"><a href="#模拟访问应用" class="headerlink" title="模拟访问应用"></a>模拟访问应用</h5><p>  Linux自带的一些工具可以模拟访问应用，比如<code>curl</code>命令，能够模拟http请求，当然还有其他附加功能，本文所讲的模拟http请求只是它的一个小模块。</p><ol><li><p>模拟GET请求</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaocanghai /]# curl -l baidu.com</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;meta http-equiv="refresh" content="0;url=http://www.baidu.com/"&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li>模拟POST请求</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaocanghai /]# curl -d "wd=test" "https://www.baidu.com"</span><br></pre></td></tr></table></figure><h5 id="查看日志状态"><a href="#查看日志状态" class="headerlink" title="查看日志状态"></a>查看日志状态</h5><p>使用<code>tail</code>命令查看日志，<code>tail</code>就是尾巴的意思，就是说查看文件的尾部，<code>tail -nf</code>命令-n表示输出文件尾部n行数据，-f表示显示文件最新追加的内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaocanghai conf.d]# tail -5f /var/log/nginx/nginx.access.log</span><br><span class="line">203.208.60.215 - - [17/Jun/2018:22:16:28 +0800] "GET /blog/query/ HTTP/1.1" 404 126 "https://www.xiaocanghai.com/blog-show.html?blogId=" "Mozilla/5.0 AppleWebKit/537.36 (KHTML, like Gecko; compatible; Googlebot/2.1; +http://www.google.com/bot.html) Safari/537.36" "-"</span><br><span class="line">203.208.60.215 - - [17/Jun/2018:22:16:28 +0800] "GET /blog-list.html HTTP/1.1" 404 143 "https://www.xiaocanghai.com/blog-show.html?blogId=" "Mozilla/5.0 AppleWebKit/537.36 (KHTML, like Gecko; compatible; Googlebot/2.1; +http://www.google.com/bot.html) Safari/537.36" "-"</span><br><span class="line">203.208.60.214 - - [17/Jun/2018:22:16:45 +0800] "OPTIONS /blog/queryBlogList?pageNum=1&amp;pageSize=10 HTTP/1.1" 200 0 "http://www.xiaocanghai.com/" "Mozilla/5.0 AppleWebKit/537.36 (KHTML, like Gecko; compatible; Googlebot/2.1; +http://www.google.com/bot.html) Safari/537.36" "-"</span><br><span class="line">203.208.60.214 - - [17/Jun/2018:22:16:46 +0800] "GET /blog-list.html HTTP/1.1" 404 143 "http://www.xiaocanghai.com/" "Mozilla/5.0 AppleWebKit/537.36 (KHTML, like Gecko; compatible; Googlebot/2.1; +http://www.google.com/bot.html) Safari/537.36" "-"</span><br><span class="line">74.82.47.3 - - [17/Jun/2018:23:40:37 +0800] "GET / HTTP/1.1" 200 5723 "-" "-" "-"</span><br></pre></td></tr></table></figure><p>如果访问应用能够实时看到日志在输出，那说明应用状态是运行中。但应用访问没有日志输出，且并没有返回结果，说明是处于假死状态。</p><h3 id="确定应用状态后，定位错误原因"><a href="#确定应用状态后，定位错误原因" class="headerlink" title="确定应用状态后，定位错误原因"></a>确定应用状态后，定位错误原因</h3><p>确定应用状态后，可以进一步定位错误的细节。一般而言定位错误描述与错误原因，基本上就是查看日志，搜索日志。那查看日志的时候，一般不能用<code>vi/vim</code>命令，因为采用这个命令会占用CPU，从而影响应用本身。可以使用<code>view</code>/<code>less</code>/<code>more</code>等查看命令进行查看/搜索日志。</p><h4 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h4><p>定位错误原因，一般可以先采用<code>grep</code>搜索日志文件，根据报错的相关信息，如用户的证件号、session id、错误提示进行搜索日志。先根据比较泛的信息搜索出所有的相关信息，然后再根据更细节的信息进行搜索。比如查询nginx日志，可以直接用404搜索日志文件，然后可以在这些信息找到要定位的请求，再用请求信息进行搜索。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@xiaocanghai conf.d]# grep '404' /var/log/nginx/nginx.access.log</span><br><span class="line">47.96.231.74 - - [17/Jun/2018:17:00:55 +0800] "HEAD /redirect.php HTTP/1.1" 404 0 "-" "-" "-"</span><br><span class="line">203.208.60.216 - - [17/Jun/2018:18:37:30 +0800] "GET /robots.txt HTTP/1.1" 404 0 "-" "Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)" "-"</span><br><span class="line">203.208.60.215 - - [17/Jun/2018:18:38:08 +0800] "GET /blog-list.html HTTP/1.1" 404 143 "-" "Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)" "-"</span><br><span class="line">95.163.255.7 - - [17/Jun/2018:18:55:43 +0800] "GET /robots.txt HTTP/1.0" 404 114 "-" "Mozilla/5.0 (compatible; Linux x86_64; Mail.RU_Bot/2.0; +http://go.mail.ru/help/robots)" "-"</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要讲了如何在Linux服务器上定位应用出现的错误或异常，总体原则是：<strong>先总体，后局部</strong>，先查看应用与服务器的当前状态，然后进一步查看应用日志定位错误细节。一般查问题的顺序是：先查看应用状态，再看应用日志定位细节，再查看服务器状态。之所以把服务器状态放在最后，是因为大部分应用报错是自身的问题。       </p>]]></content>
      
      <categories>
          
          <category> 2018 </category>
          
          <category> 技术总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式之模板方法</title>
      <link href="/2018/06/04/template-method/"/>
      <url>/2018/06/04/template-method/</url>
      <content type="html"><![CDATA[<blockquote><p>模板方法(Template Method )顾名思义，是指父类提供一个模板或者说框架，然后再子类中填充具体的内容。在模板方法中父类定义或者说抽象出一套算法的流程或者说步骤，然后子类负责实现一个或多个步骤，并且可以在不改变算法的架构的基础上，改变算法的某些步骤。       </p></blockquote><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>模板方法针对的场景其实是那些可以归纳出步骤的事情，但步骤的具体内容有可以不同。针对这种事情采用面向对象的抽象出这些步骤，定义成模板方法。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>比如人的一生，就可以抽象出几个步骤：1、出生；2、生活；3、死亡。相信这是绝大部分人的人生模板，人的一生都是这些步骤进行的，然后可能人生的步骤可能有些不一样，可能有些人出生在医院中，有些人出生在家里，甚至是野外（比如郭靖），生活同样大家都生活得不一样。上天对人生的步骤就是如下进行安排的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractLife</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模板方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">living</span><span class="params">()</span></span>&#123;</span><br><span class="line">        born();</span><br><span class="line">        live();</span><br><span class="line">        death();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">born</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">live</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">death</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Everyone will die"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类定义了四个方法，其中<code>living</code>方法是模板方法，<code>death</code>方法是私有的方法，因为这个方法是通用的，所以无需子类重写，其中<code>born</code>与<code>live</code>方法需要子类重写，根据子类自身的内容去重写。还有一个<code>final</code>定义的<code>living</code>方法，这个方法就是模板方法，定义方法执行的步骤。</p><p>现在有了上面抽象类与模板方法，就可以对<code>AbstractLife</code>进行继承，并重写<code>born</code>与<code>live</code>方法，然后使用该实现类的对象调用<code>living</code>方法，即可完成人一生的步骤。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodLife</span> <span class="keyword">extends</span> <span class="title">AbstractLife</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">born</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Born at own home"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">live</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Take on your own responsibility"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Do some good thing"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Do some interest"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractLife life = <span class="keyword">new</span> GoodLife();</span><br><span class="line">        life.living();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">//Born at own home</span></span><br><span class="line"><span class="comment">//Take on your own responsibility</span></span><br><span class="line"><span class="comment">//Do some good thing</span></span><br><span class="line"><span class="comment">//Do some interest</span></span><br><span class="line"><span class="comment">//Everyone will die</span></span><br></pre></td></tr></table></figure><h1 id="钩子方法"><a href="#钩子方法" class="headerlink" title="钩子方法"></a>钩子方法</h1><p>模板方法定义了算法的执行步骤，但如果某些步骤或者说步骤顺序对于某些子类来说不执行或者说执行步骤不一样，这就要用到钩子方法了，钩子方法是定义在抽象类中的一种方法，子类可以覆盖它，通过覆盖钩子方法可以让子类改变是否执行算法步骤，或者改变步骤顺序。钩子方法本质提供一种可以让子类可以进行对模板方法进行变通的方法。</p><p>还是以上面的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractLife</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模板方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">living</span><span class="params">()</span></span>&#123;</span><br><span class="line">        born();</span><br><span class="line">        live();</span><br><span class="line">        <span class="keyword">if</span>(isDreamWorld())&#123;</span><br><span class="line">            death();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">born</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">live</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">death</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Everyone will die"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 钩子函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isDreamWorld</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类实现钩子方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodLife</span> <span class="keyword">extends</span> <span class="title">AbstractLife</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">born</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Born at own home"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">live</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Take on your own responsibility"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Do some good thing"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Do some interest"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isDreamWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>模板方法是基于面向对象的封装方法，将算法的执行步骤进行封装，定义一个包含模板方法的抽象类，通常设置模板方法为<code>final</code>，具体的子类可以实现抽象类中某些具体步骤，不同的子类拥有不同的实现。模板方法还提供一个钩子方法用于子类一定程度的改变算法执行步骤。</p>]]></content>
      
      <categories>
          
          <category> 2018 </category>
          
          <category> 技术总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式之状态模式</title>
      <link href="/2018/05/27/state-pattern/"/>
      <url>/2018/05/27/state-pattern/</url>
      <content type="html"><![CDATA[<blockquote><p>状态(State)模式是一种利用状态来决定对象行为的设计模式。</p></blockquote><h1 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h1><p>​    假设现在让你给空调写一个实现方法，假定空调只有三个状态：关闭、制冷、制热。按照传统的结构式编程的写法，首先定义空调的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> OFF = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> COLD = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> HOT = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>然后确定触发空调的行为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开机</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOn</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 关机</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOff</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 制冷</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnCold</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 制热</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnHot</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>然后针对具体行为进行实现，加上逻辑判断对不同状态进行修改。实际代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AirConditioning</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> OFF = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> COLD = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> HOT = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AirConditioning</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.state = OFF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state == OFF) &#123;</span><br><span class="line">            System.out.println(<span class="string">"空调正在开机"</span>);</span><br><span class="line">            <span class="comment">// 默认为制冷模式</span></span><br><span class="line">            state = COLD;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == COLD) &#123;</span><br><span class="line">            System.out.println(<span class="string">"空调已经开机"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == HOT) &#123;</span><br><span class="line">            System.out.println(<span class="string">"空调已经开机"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state == OFF) &#123;</span><br><span class="line">            System.out.println(<span class="string">"空调已经关闭"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == COLD) &#123;</span><br><span class="line">            System.out.println(<span class="string">"空调正在关闭"</span>);</span><br><span class="line">            state = OFF;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == HOT) &#123;</span><br><span class="line">            System.out.println(<span class="string">"空调正在关闭"</span>);</span><br><span class="line">            state = OFF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnCold</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state == OFF) &#123;</span><br><span class="line">            System.out.println(<span class="string">"请开启空调！"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == COLD) &#123;</span><br><span class="line">            System.out.println(<span class="string">"空调已经为制冷状态"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == HOT) &#123;</span><br><span class="line">            System.out.println(<span class="string">"正在转为制冷模式"</span>);</span><br><span class="line">            state = COLD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnHot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state == OFF) &#123;</span><br><span class="line">            System.out.println(<span class="string">"请开启空调！"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == COLD) &#123;</span><br><span class="line">            System.out.println(<span class="string">"正在转为制热模式"</span>);</span><br><span class="line">            state = HOT;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == HOT) &#123;</span><br><span class="line">            System.out.println(<span class="string">"空调已经为制热模式"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"AirConditioning&#123;"</span> + <span class="string">"name='"</span></span><br><span class="line">                + name + <span class="string">"',state="</span> + state +</span><br><span class="line">                <span class="string">"&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AirConditioning airConditioning = <span class="keyword">new</span> AirConditioning(<span class="string">"海尔空调"</span>);</span><br><span class="line">        airConditioning.turnOn();</span><br><span class="line">        airConditioning.turnCold();</span><br><span class="line">        System.out.println(airConditioning.toString());</span><br><span class="line">        airConditioning.turnHot();</span><br><span class="line">        airConditioning.turnHot();</span><br><span class="line">        System.out.println(airConditioning.toString());</span><br><span class="line">        airConditioning.turnOff();</span><br><span class="line">        airConditioning.turnCold();</span><br><span class="line">        System.out.println(airConditioning.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照上面的写法确实能够满足已有的业务，但是假设突然业务发生变化，突然增加一个状态的话：扫风，这就很尴尬了，需要修改以前的代码了，会增加if/else代码，如果业务复杂的话还可能导致出现难以发现的bug。</p><h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><p>上面的代码每个状态全部都耦合在一起了，按照面向对象的设计原则应该把每个状态抽象成独立类，并且将空调类的操作委托给状态类对象。</p><p>实际重构方案：</p><ol><li>首先抽象出一个<code>state</code>接口，接口里对应外部操作的方法，如空调遥控器的按钮。</li><li>为机器每个状态实现状态类，该状态类负责在对应的状态进行机器的行为。</li><li>将操作委托到状态类对象中。</li></ol><h2 id="基于状态模式重构"><a href="#基于状态模式重构" class="headerlink" title="基于状态模式重构"></a>基于状态模式重构</h2><ol><li><p>抽象出<code>state</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空调对应的所有行为接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018-05-27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开机</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">turnOn</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关机</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">turnOff</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 制冷</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">turnCold</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 制热</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">turnHot</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>为每个状态独立实现状态类。下面的代码为关闭状态实现独立类。从下面的代码可知状态类必须与关联对象绑定在一起，可以称关联对象为状态的上下文(<code>Context</code>)。空调类就是关闭状态的<code>Context</code>。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OffState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AirConditioner airConditioner;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OffState</span><span class="params">(AirConditioner airConditioner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.airConditioner = airConditioner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"空调正在开机"</span>);</span><br><span class="line">        <span class="comment">// 默认为制冷模式</span></span><br><span class="line">        airConditioner.setState(airConditioner.getColdState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"空调已经关闭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnCold</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"空调已经关闭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnHot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"空调已经关闭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将操作委托到状态类对象中。当调用上下文的操作方式时，上下文会将操作委托给状态对象，状态对象根据自己的业务逻辑，产生相应的动作并且改变上下文的状态。然后下一步操作，又会根据不同的状态对象产生不同的行为。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AirConditioner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OffState offState;</span><br><span class="line">    <span class="keyword">private</span> ColdState coldState;</span><br><span class="line">    <span class="keyword">private</span> HotState hotState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AirConditioner</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        offState = <span class="keyword">new</span> OffState(<span class="keyword">this</span>);</span><br><span class="line">        coldState = <span class="keyword">new</span> ColdState(<span class="keyword">this</span>);</span><br><span class="line">        hotState = <span class="keyword">new</span> HotState(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.state = offState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state.turnOn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state.turnOff();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnCold</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state.turnCold();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnHot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state.turnHot();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// getter与setter方法省略</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"AirConditioning&#123;"</span> + <span class="string">"name='"</span></span><br><span class="line">                + name + <span class="string">"',state="</span> + state.getClass().getSimpleName() +</span><br><span class="line">                <span class="string">"&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="增加新的状态"><a href="#增加新的状态" class="headerlink" title="增加新的状态"></a>增加新的状态</h2><p>如果要加入新的状态：扫风，只需新增新状态的实现类，然后部分修复行为代码即可，有兴趣的可以自己实现一下。状态模式符合满足面向对象的设计原则：<strong>对扩展开发，对修改关闭</strong>。具体的状态类对修改关闭，而对新的状态可以添加进来。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这种通过改变对象状态来改变对象的行为就是状态今天要提到的状态模式（State Pattern）了。状态模式是指<strong>允许对象通过改变状态时改变它的行为，对象好像修改了它的类</strong>。</p><p>这句话怎么理解呢？首先前半句：状态模式将状态封装成独立的类，并将动作委托给当前状态的对象，从而达到修改对象状态改变对象的行为。后半句：它是在客户而言使用的对象能够改变行为，好像是采用了不同的类进行实现一样，但实际上是通过组合的方式引用不同的对象来造成类改变的假象。</p><h1 id="状态模式分析"><a href="#状态模式分析" class="headerlink" title="状态模式分析"></a>状态模式分析</h1><p>状态模式其实可以分为三个角色：</p><p><code>Context</code>: <code>Context</code>持有当前当前状态的实例，还提供外部使用者调用的操作接口。</p><p><code>state</code>: 表示状态，定义不同状态的进行不同处理的接口，定义了依赖状态的处理方法集合。</p><p><code>ConcreteState</code>：每个子类实现与场景类（<code>Context</code>）每个状态相关的行为 </p><p><img src="http://dreamrunner.org/images/blog/2014/state/state_structure.jpeg" alt="状态模式UML图"></p><p>​                                                        状态模式结构</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从上面的代码可以看出状态模式适合对象有确定确定状态且行为比较固定的的场景，能够明确对象的状态，然后为不同状态实现状态类，执行<code>Context</code>的委托操作。</p>]]></content>
      
      <categories>
          
          <category> 2018 </category>
          
          <category> 技术总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CGLIB与动态代理</title>
      <link href="/2018/05/13/cglib-and-dynamic-proxy/"/>
      <url>/2018/05/13/cglib-and-dynamic-proxy/</url>
      <content type="html"><![CDATA[<h1 id="CGLIB介绍"><a href="#CGLIB介绍" class="headerlink" title="CGLIB介绍"></a>CGLIB介绍</h1><blockquote><p>Cglib(Byte Code Generation Library )是一个高层次的生成与转化Java字节码的API。之所以称为高层次是因为它底层采用ASM(字节码操作框架）。通过生成动态代理对象与拦截属性访问，cglib使用在AOP，测试，数据访问框架中。</p><p>常用的使用框架：Spring ，Hibernate，Mybatis。</p></blockquote><h1 id="CGLIB原理"><a href="#CGLIB原理" class="headerlink" title="CGLIB原理"></a>CGLIB原理</h1><h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><p>Cglib是字节码生成工具包，字节码指Java字节码，通常开发Java编写的为Java源文件，以.java结尾，然后用编译器编译成class文件。class文件就是字节码文件，可以用编辑器打开，可以看到class文件对应的为二进制文件，它包含的是与平台无关的能被JVM执行的指令格式，所以称之为字节码文件。</p><p>JVM能够读取所有符合JVM规范的字节码。JAVA字节码不仅能够以文件的形式存储在磁盘上，还可以以网络的方式进行下载，还可以存在内存中。JVM中的类加载器会负责将包含字节代码的字节数组(byte[])中定义出类。在某些时候，可以动态生成Java字节码，或者对已有的字节码进行修改，在这里就要提到本文提到的ASM与CGLIB了。CGLIB本质就是封装了ASM，简化了ASM的操作，实现了在运行器生成新的字节码。</p><h2 id="CGLIB结构"><a href="#CGLIB结构" class="headerlink" title="CGLIB结构"></a>CGLIB结构</h2><p><img src="http://jnb.ociweb.com/jnb/jnbNov2005_files/jnbNov2005-1.PNG" alt="CGLIB组成结构"></p><p>#CGLIB实现动态代理</p><p>之前的博客写过采用JDK自带的代理类实现动态代理，但必须代理类与被代理类必须实现同一接口，这就限制了某些没有实现接口的类的动态代理功能。采用CGLIB类实现的动态代理无需实现通过接口，下面进行具体介绍。</p><ol><li>导入maven包。直接引入cglib-nodep包，这样就无需导入其他包，直接引入cglib需要依赖其他的包</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib-nodep<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>定义业务逻辑。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>实现MethodInterceptor接口，定义方法的拦截器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> obj         被代理对象</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> method      被代理方法</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> args        参数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> methodProxy 代理方法</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 代理对象</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"Before: "</span> + method);</span><br><span class="line">       Object object = methodProxy.invokeSuper(obj, args);</span><br><span class="line">       System.out.println(<span class="string">"After: "</span> + method);</span><br><span class="line">       <span class="keyword">return</span> object;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取代理对象</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> clazz 被代理类型</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">       Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">       enhancer.setSuperclass(clazz);</span><br><span class="line">       enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">       <span class="keyword">return</span> (T)enhancer.create();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>验证</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将代理类输出到指定目录</span></span><br><span class="line">     System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, <span class="string">"D:/temp/classes"</span>);</span><br><span class="line">     CglibProxy cglibProxy = <span class="keyword">new</span> CglibProxy();</span><br><span class="line">     TestService testService = cglibProxy.getProxy(TestService.class);</span><br><span class="line">     testService.sayHello();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>运行结果</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CGLIB debugging enabled, writing to 'D:/temp/classes'</span><br><span class="line">Before: public void org.chason.bytecode.TestService.sayHello()</span><br><span class="line">Hello</span><br><span class="line">After: public void org.chason.bytecode.TestService.sayHello()</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>基于CGLIB实现的动态代理相比JDK动态代理而言，无侵入型，无需实现接口。基于对字节码的修改，生成要代理类的子类，然后再子类中回调代理类的方法。但要注意CGLIB无法代理基于Final或private修饰的方法。</p>]]></content>
      
      <categories>
          
          <category> 2018 </category>
          
          <category> 技术总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态代理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>自己实现Spring</title>
      <link href="/2018/04/22/build-own-spring/"/>
      <url>/2018/04/22/build-own-spring/</url>
      <content type="html"><![CDATA[<blockquote><p>Spring 相信只要学过Java的程序员没有不知道的，Spring发展到现在现在已经到5.0版本了，已经变得非常的庞杂了，对于初级程序员来说太复杂了。今天我尝试着实现简易版本的Spring，来了解Spring其本质。</p></blockquote><h1 id="Spring的核心"><a href="#Spring的核心" class="headerlink" title="Spring的核心"></a>Spring的核心</h1><p>Spring发展到现在已经非常复杂了，它的基本架构图如下所示：</p><p><img src="https://www.ibm.com/developerworks/cn/java/wa-spring1/spring_framework.gif" alt="Spring架构图"></p><p>​                 <strong>Spring架构图</strong></p><p>从上图可以知道Spring的核心是容器管理，Spring通过容器管理不同服务的组件，为其他功能提供基础。</p><p>我们经常可以听到说Spring的两个特性：IOC（控制反转）与AOP（面向切面编程）。</p><ol><li>IOC（控制反转）是指不主动创建对象，但描述对象的创建方式。由IOC容器管理对象之间的依赖，并负责对象的创建。</li><li>AOP（面向方面编程）：它是一种编程方法，与普通的编程关注功能点不一样，它关注横切关注点，称为方面，它将那些影响多个类的行为封装到可重用的模块之中。</li></ol><h1 id="实现Spring"><a href="#实现Spring" class="headerlink" title="实现Spring"></a>实现Spring</h1><p>本文只实现Spring的IOC功能，即简易实现Spring的容器管理与依赖注入功能。既然要实现Spring的IOC功能：那我们首先思考几个问题：</p><ol><li>IOC容器管理的Bean是什么？</li><li>IOC容器中的Bean从何而来？</li><li>IOC容器怎么管理Bean？</li><li>IOC容器怎么实现IOC(控制反转)？</li></ol><h2 id="IOC容器管理的Bean是什么？"><a href="#IOC容器管理的Bean是什么？" class="headerlink" title="IOC容器管理的Bean是什么？"></a>IOC容器管理的Bean是什么？</h2><p>Spring容器中管理的基础对象Bean，但Bean是什么呢？它可以看住普通对象的一种封装，容器管理的管理对象。那怎么定义这个Bean呢?下面设计一个类定义Bean的属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefine</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id; <span class="comment">// bean ID，作为容器中的唯一标识</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; type;  <span class="comment">// bean对应的类型</span></span><br><span class="line">    <span class="keyword">private</span> String className; <span class="comment">// bean对应的类的名称，以后可以使用这个属性创建对象</span></span><br><span class="line">    <span class="keyword">private</span> Object bean;   <span class="comment">// Bean对象，有可能为null，因为懒加载的时候，不需要创建对应的实例对象</span></span><br><span class="line">    <span class="keyword">private</span> PropertieValues propertieValues; <span class="comment">// 对象依赖的属性值列表</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanDefine</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.className = className;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// setter与getter方式省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么设计成上面这样呢？比如构造方法只能传入className，这是为了之后IOC容器采用<code>className</code>创建对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class PropertieValues &#123;</span><br><span class="line">   private List&lt;PropertieValue&gt; propertieValues = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void addProperties(PropertieValue propertieValue) &#123;</span><br><span class="line">        for (PropertieValue iter : propertieValues) &#123;</span><br><span class="line">            iter.getKey().equals(propertieValue.getKey()) &#123;</span><br><span class="line">                throw new RuntimeException(&quot;Properties value is repeat&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        propertieValues.add(propertieValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // setter与getter方式省略</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PropertieValue &#123;</span><br><span class="line">    private String key;</span><br><span class="line">    private Object value;</span><br><span class="line"></span><br><span class="line">    // setter与getter方式省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象属性值列表采用PropertieValues对象的形式，主要是为了对属性值进行判断，因为需要对象属性添加的时候，需要防止出现重复，所以加了一层封装。</p><h2 id="IOC容器中的Bean从何而来？"><a href="#IOC容器中的Bean从何而来？" class="headerlink" title="IOC容器中的Bean从何而来？"></a>IOC容器中的Bean从何而来？</h2><p>定义好了Bean，那Bean从何而来呢？传统的Spring配置是基于XML配置对Bean与Bean直接的依赖进行描述（当然也可以采用注解的方法，之后会在另外的文件进行介绍）。XML配置形如下面的描述：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"outputService"</span> <span class="attr">class</span>=<span class="string">"chason.learning.ioc.service.OutputService"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorldService"</span> <span class="attr">class</span>=<span class="string">"chason.learning.ioc.service.HelloWorldServiceImpl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"Hello World!"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"20"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"outputService"</span> <span class="attr">ref</span>=<span class="string">"outputService"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然上面class是对应项目中存在的类的全路径，id名称标识Bean对象，而<code>helloWorldService</code>中包含多种属性值，即有基本类型的属性，也有对象类型的属性，属性值为引用类型是采用ref标识。那怎么读取这样的配置文件，创建对应Bean呢？肯定得解析XML文件啊。</p><p>那怎么获取配置文件地址、读取配置并顺利解析出bean对象呢？</p><ol><li>首先抽象一个资源类，描述配置的抽象含义</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> URL url;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Resource</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> url == <span class="keyword">null</span> ? <span class="keyword">null</span> : url.openStream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>然后定义一个资源加载类，可以从配置文件路径读取文件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Resource <span class="title">getResource</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">        URL url = <span class="keyword">this</span>.getClass().getClassLoader().getResource(location);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Resource(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>获取配置文件之后进行XML解析。</li></ol><p>前面对资源的定位进行抽象，现在定义获取BeanDefine进行抽象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefineReader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loadBeanDefine</span><span class="params">(String location)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后实现XML对Bean配置的解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanDefineReader</span> <span class="keyword">implements</span> <span class="title">BeanDefineReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, BeanDefine&gt; registry = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XmlBeanDefineReader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBeanDefine</span><span class="params">(String location)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        InputStream inputStream = resourceLoader.getResource(location).getInputStream();</span><br><span class="line">        doLoadBeanDefine(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doLoadBeanDefine</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();</span><br><span class="line">        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();</span><br><span class="line">        Document document = documentBuilder.parse(inputStream);</span><br><span class="line">        parseBeanDefinitions(document.getDocumentElement());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        NodeList nodeList = root.getChildNodes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodeList.getLength(); i++) &#123;</span><br><span class="line">            Node node = nodeList.item(i);</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                Element element = (Element) node;</span><br><span class="line">                BeanDefine beanDefinition = processBeanDefinition(element);</span><br><span class="line">                registry.put(beanDefinition.getId(), beanDefinition);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> BeanDefine <span class="title">processBeanDefinition</span><span class="params">(Element element)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        String id = element.getAttribute(<span class="string">"id"</span>);</span><br><span class="line">        String className = element.getAttribute(<span class="string">"class"</span>);</span><br><span class="line">        BeanDefine beanDefinition = <span class="keyword">new</span> BeanDefine(className);</span><br><span class="line">        beanDefinition.setId(id);</span><br><span class="line">        beanDefinition.setType(Class.forName(className));</span><br><span class="line">        processProperty(beanDefinition, element);</span><br><span class="line">        <span class="keyword">return</span> beanDefinition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processProperty</span><span class="params">(BeanDefine beanDefinition, Element ele)</span> </span>&#123;</span><br><span class="line">        NodeList nodeList = ele.getElementsByTagName(<span class="string">"property"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodeList.getLength(); i++) &#123;</span><br><span class="line">            Node node = nodeList.item(i);</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                Element propertyNode = (Element) node;</span><br><span class="line">                String name = propertyNode.getAttribute(<span class="string">"name"</span>);</span><br><span class="line">                String value = propertyNode.getAttribute(<span class="string">"value"</span>);</span><br><span class="line">                <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; value.length() != <span class="number">0</span>) &#123;</span><br><span class="line">                    beanDefinition.getPropertieValues().addProperties(<span class="keyword">new</span> PropertieValue(name, value));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    String ref = propertyNode.getAttribute(<span class="string">"ref"</span>);</span><br><span class="line">                    <span class="keyword">if</span> (ref == <span class="keyword">null</span> || ref.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"The configuration problem: the &lt;property&gt; must specify a value or a ref"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    BeanReference beanReference = <span class="keyword">new</span> BeanReference(ref);</span><br><span class="line">                    beanDefinition.getPropertieValues().addProperties(<span class="keyword">new</span> PropertieValue(name, beanReference));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, BeanDefine&gt; <span class="title">getRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> registry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##IOC容器怎么管理Bean？</p><p>上面成功解析出Bean后应该讲Bean放入容器中。怎么存放，创建与使用Bean呢？首先定义一个抽象接口表示如何获取Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义一个抽象类管理Bean对象的获取与创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanFactory</span> <span class="keyword">implements</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, BeanDefine&gt; beanDefineMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取Bean对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        BeanDefine beanDefine = beanDefineMap.get(name);</span><br><span class="line">        <span class="keyword">if</span> (beanDefine == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No bean named "</span> + name + <span class="string">" is defined"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Object bean = beanDefine.getBean();</span><br><span class="line">        <span class="keyword">if</span> (bean == <span class="keyword">null</span>) &#123;</span><br><span class="line">            bean = doCreateBean(beanDefine);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册Bean定义对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String name, BeanDefine beanDefine)</span> </span>&#123;</span><br><span class="line">        beanDefineMap.put(name, beanDefine);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Bean对象</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">doCreateBean</span><span class="params">(BeanDefine beanDefine)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后实现Bean的创建与属性注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(BeanDefine beanDefine)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object bean = createBeanInstance(beanDefine);</span><br><span class="line">        beanDefine.setBean(bean);</span><br><span class="line">        applyPropertyValues(bean, beanDefine);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">createBeanInstance</span><span class="params">(BeanDefine beanDefine)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanDefine.getClass().newInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPropertyValues</span><span class="params">(Object bean, BeanDefine mbd)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (PropertieValue propertyValue : mbd.getPropertieValues().getPropertieValues()) &#123;</span><br><span class="line">            Field declaredField = bean.getClass().getDeclaredField(propertyValue.getKey());</span><br><span class="line">            declaredField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Object value = propertyValue.getValue();</span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> BeanReference) &#123;</span><br><span class="line">                BeanReference beanReference = (BeanReference) value;</span><br><span class="line">                value = getBean(beanReference.getName());</span><br><span class="line">            &#125;</span><br><span class="line">            declaredField.set(bean, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IOC容器怎么实现IOC"><a href="#IOC容器怎么实现IOC" class="headerlink" title="IOC容器怎么实现IOC"></a>IOC容器怎么实现IOC</h2><p>上一节介绍了如何将Bean进行注册，如何获取Bean、创建Bean与注入属性，那么得到BeanFactory如何进行IOC呢？Spring会采用ApplicationContext来管理Bean与IOC。</p><p>首先定义ApplicationContext接口，直接继承BeanFactory接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> <span class="keyword">extends</span> <span class="title">BeanFactory</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义实现ApplicationContext的抽象类，它内部采用BeanFacatory管理Bean容器，BeanFacatory负责Bean对象的注册、创建、属性注入、获取，而ApplicationContext在此基础上提供给开发者框架功能。BeanFacatory是Spring内部的，而ApplicationContext是Spring提供给外部使用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">implements</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> AbstractBeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">(AbstractBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanFactory.getBean(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为本文是基于XML对上下文进行配置的，所以实现对XML配置的上下文进行解析的ClassPathXmlApplicationContext类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String configLocation;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String configLocation)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(configLocation, <span class="keyword">new</span> AutowireCapableBeanFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String configLocation, AbstractBeanFactory beanFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(beanFactory);</span><br><span class="line">        <span class="keyword">this</span>.configLocation = configLocation;</span><br><span class="line">        refresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        XmlBeanDefineReader xmlBeanDefinitionReader = <span class="keyword">new</span> XmlBeanDefineReader(<span class="keyword">new</span> ResourceLoader());</span><br><span class="line">        xmlBeanDefinitionReader.loadBeanDefine(configLocation);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, BeanDefine&gt; beanDefinitionEntry : xmlBeanDefinitionReader.getRegistry().entrySet()) &#123;</span><br><span class="line">            beanFactory.registerBeanDefinition(beanDefinitionEntry.getKey(), beanDefinitionEntry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathXmlApplicationContextTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"config.xml"</span>);</span><br><span class="line">        HelloWorldService helloWorldService = (HelloWorldService) applicationContext.getBean(<span class="string">"helloWorldService"</span>);</span><br><span class="line">        helloWorldService.helloWorld();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了实现Spring的核心功能——IOC容器，依次从如何定义Bean，注册Bean，管理Bean，最后如何管理IOC，基于XML配置Bean对象之间的依赖，之后会介绍采用注解的方式创建Bean对象。</p><p>github地址：<a href="https://github.com/cangqiong/my-little-spring" target="_blank" rel="noopener">https://github.com/cangqiong/my-little-spring</a></p>]]></content>
      
      <categories>
          
          <category> 2018 </category>
          
          <category> 技术总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码实现 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>正则表达式</title>
      <link href="/2018/04/15/regular-expression/"/>
      <url>/2018/04/15/regular-expression/</url>
      <content type="html"><![CDATA[<blockquote><p>在日常工作中，编辑文本或网页的时候，经常会用磁盘搜索功能或者在文本中搜索某个单词。例如：用记事本打开个文档后，搜索“测试”，就可以匹配到当前文档中“测试”这个词。</p></blockquote><blockquote><p>那有没有更加强大的文本匹配工具，给开发人员或者运维人员使用呢？一种不需要知道要匹配的值，只需知道要匹配的值满足的规则。这就要提起从Unix系统就开始使用的正则表达式了。</p></blockquote><blockquote><p>正则表达式（regular expression）其实就是使用特定字符来匹配符合特殊字符确定的规则的字符串。</p></blockquote><p>其实正则表达式日常办公中，也经常使用。比如你打开文件管理器，在右边的搜索框，搜索“.txt”，就能搜到当前目录下的所有txt文件。这其实这就可以看成是正则表达式。</p><h1 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h1><p>上面说了正则表达式是使用特定字符来匹配想要的字符串。特定字符这里称为<strong>元字符</strong>。下面先看一个简单的实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grep -P "^test$" doc.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> grep 这是Linux自带的正则shell方法</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -P 表示采用Perl的正则表达式引擎，其实不加这个也可以，但有些元字符用不了</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="string">"^test$"</span> 为正则表达式，其中^与$为元字符，<span class="built_in">test</span>为普通字符</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> doc.txt 匹配的目标文档</span></span><br></pre></td></tr></table></figure><p>如上所述：<code>^</code>与<code>$</code>为元字符,<code>^</code>表示一行的开始，而<code>$</code>为一行的结束，上面的正则表达式的含义是：匹配以<em>test</em>开头语且以<em>test</em>结尾的字符串。</p><p>其中doc.txt的文本为</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">subject:测试正则表达式</span><br><span class="line">from: test123@163.com</span><br><span class="line">to: test456@163.com</span><br><span class="line">dear one:</span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">  <span class="built_in">test</span></span><br><span class="line">        today has a rain.</span><br><span class="line">TODAY IS A GOOD DAY</span><br><span class="line">abcderfghghghg</span><br><span class="line">123892332432</span><br><span class="line">789</span><br><span class="line">020-12345678</span><br><span class="line">telethone:020-79788888</span><br><span class="line">dfdf22测试中文字符串</span><br><span class="line">\s\d\S\w</span><br><span class="line">ip:22.105.145.123</span><br><span class="line">              the best wish!.</span><br></pre></td></tr></table></figure><p>上面的执行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaocanghai regex]# grep -P "^test$" doc.txt</span><br><span class="line">test</span><br></pre></td></tr></table></figure><p>那如果要搜索电话号码呢？可以用下面的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaocanghai regex]# grep -P "\w+@\w+\.\w+" doc.txt</span><br><span class="line">from: test123@163.com</span><br><span class="line">to: test456@163.com</span><br></pre></td></tr></table></figure><p>上面的<code>\w</code>明显就是元字符，它表示一个单词，指字母或数字或者小划线。常用的元字符如下所示</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>匹配除换行符以外的任意字符</td></tr><tr><td>\w</td><td>匹配字母或数字或下划线或汉字</td></tr><tr><td>\s</td><td>匹配任意的空白符</td></tr><tr><td>\d</td><td>匹配数字</td></tr><tr><td>\b</td><td>匹配单词的开始或结束</td></tr><tr><td>^</td><td>匹配字符串的开始</td></tr><tr><td>$</td><td>匹配字符串的结束</td></tr></tbody></table><p>那如果想匹配其中某个词，可以用<code>\b</code>+词+<code>\b</code>进行搜索，比如搜索a，只想搜索到词a（一个），而不是字母a。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaocanghai regex]# grep -P "\ba\b" doc.txt</span><br><span class="line">        today has a rain.</span><br></pre></td></tr></table></figure><h1 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h1><p>那如果想搜索上面文本的电话号码，按照给定的元字符，可以这样搜索：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaocanghai regex]# grep -P "0\d\d-\d\d\d\d\d\d\d\d" doc.txt</span><br><span class="line">020-12345678</span><br><span class="line">telethone:020-79788888</span><br></pre></td></tr></table></figure><p>但感觉是不是有点麻烦，上面的元字符只能匹配一个字符，匹配电话号码，还得10个元字符，这也太麻烦了，可以采用量词进行匹配：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaocanghai regex]# grep -P "0\d&#123;2&#125;-\d&#123;8&#125;" doc.txt</span><br><span class="line">020-12345678</span><br><span class="line">telethone:020-79788888</span><br></pre></td></tr></table></figure><p>上面的{2}表示匹配两个满足\d规则的字符，{8}自然是匹配八个满足\d规则的字符。除了这种量词，还有其他量词</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>重复零次或更多次</td></tr><tr><td>+</td><td>重复一次或更多次</td></tr><tr><td>?</td><td>重复零次或一次</td></tr><tr><td>{n}</td><td>重复n次</td></tr><tr><td>{n,}</td><td>重复n次或更多次</td></tr><tr><td>{n,m}</td><td>重复n到m次</td></tr></tbody></table><p>量词其实就是对前面的元字符的个数的描述。比如想匹配第一行以a开头的字符串：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaocanghai regex]# grep -P "^a\w*" doc.txt</span><br><span class="line">abcderfghghghg</span><br><span class="line"><span class="meta">#</span><span class="bash"> ^a\w* 表示以a开头后面的字符不限的字符串</span></span><br></pre></td></tr></table></figure><h1 id="自定义字符"><a href="#自定义字符" class="headerlink" title="自定义字符"></a>自定义字符</h1><p>使用指定的元字符与普通字符进行能够匹配指定的字符串，但是如果自己想匹配没有预定义元字符的字符集合时，那怎么操作呢？比如查找包含元音字母的单词，怎么办。</p><p>很简单，只需要在中括号中列出来就可以了，<code>[aeiou]</code>表示aeiou中的任意字符，<code>[!?*]</code>表示其中任一字符，记住中括号括起来的的只匹配一个字符，可以使用量词进行匹配多个字符。<code>[0-9]</code> 代表的含意与 <code>\d</code> 就是完全一致的，表示从0到9的数字，中括号中的<code>-</code>表示0与9之前的区间，即一个数字。同理 <code>[a-z0-9A-Z_]</code> 也完全等同于 <code>\w</code>。下面先看一个简单的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaocanghai regex]# grep -P &quot;\b\w*[0-9]\w*\b&quot; doc.txt #匹配包含数字的词</span><br><span class="line">from: test123@163.com</span><br><span class="line">to: test456@163.com</span><br><span class="line">123892332432</span><br><span class="line">789</span><br><span class="line">020-12345678</span><br><span class="line">telethone:020-79788888</span><br><span class="line">dfdf22测试中文字符</span><br></pre></td></tr></table></figure><h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><p>通过上面的介绍，可以匹配大多数的字符串，但如果想匹配元字符对应的字符串呢？那就要用到转义字符了。</p><p>比如想匹配<code>.</code>，就可以采取加<code>\</code>的方式进行转义，这样就会取消元字符的含义。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaocanghai regex]# grep -P "\.$" doc.txt  #可以试一下不加\</span><br><span class="line">        today has a rain.</span><br><span class="line">              the best wish!.</span><br></pre></td></tr></table></figure><h1 id="选择符与分组"><a href="#选择符与分组" class="headerlink" title="选择符与分组"></a>选择符与分组</h1><p>如果想匹配满足多个表达式的字符串，这就要用到<code>|</code>，它表示或，也就是说满足两个表达式的一个就可以了。假设要搜索邮件的收件人与发件人，收件人可以用<code>^to:\w</code>，而发件人可以用<code>^from:\w</code>,两个条件综合就是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaocanghai regex]# grep -P "^(from|to)\w*" doc.txt</span><br><span class="line">from: test123@163.com</span><br><span class="line">to: test456@163.com</span><br></pre></td></tr></table></figure><p>上面的<code>(</code> 与<code>)</code>也是元字符串，可以用括号指定子表达式，也叫做分组，也可以用量词表示字表达试的次数，比如匹配IP：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaocanghai regex]# grep -P "(\d&#123;1,3&#125;\.)&#123;3&#125;\d&#123;1,3&#125;" doc.txt</span><br><span class="line">ip:22.105.145.123</span><br></pre></td></tr></table></figure><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>上面讲了如何写正则表达式，下面举几个例子说明一下正则的用途。</p><h2 id="nginx静态资源配置"><a href="#nginx静态资源配置" class="headerlink" title="nginx静态资源配置"></a>nginx静态资源配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location ~* ^.+\.(jpg|jpeg|gif|css|png|js|ico|html|txt)$ &#123; #对静态资源进行访问</span><br><span class="line">       access_log        off;</span><br><span class="line">       expires           30d;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>上面的<code>^.+\.(jpg|jpeg|gif|css|png|js|ico|html|txt)$</code>字符串就是正则表达式，匹配的是任意字符为前缀以<code>.txt/jpg/...</code>结尾的URL字符串。</p><h2 id="爬虫匹配链接"><a href="#爬虫匹配链接" class="headerlink" title="爬虫匹配链接"></a>爬虫匹配链接</h2><p>在网络爬虫中，为了抓取外链，需要通过正则表达式匹配链接。可以匹配网页html代码中的<code>&lt;a&gt;</code>链接，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a\b("[^"]*"|'[^']*'|[^'"&gt;])*&gt;</span><br></pre></td></tr></table></figure><h1 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h1><p>正则表达式有点难以理解，但功能其实很强大，其实还有其他内容没有介绍，可以看我给出的参考资料。</p><ul><li><p>文章<br>《正则表达式30分钟入门教程》</p><p>《正则表达式经典实例》</p></li><li><p>在线解析工具：<a href="https://regexper.com" target="_blank" rel="noopener">https://regexper.com</a></p></li></ul>]]></content>
      
      <categories>
          
          <category> 2018 </category>
          
          <category> 学习 </category>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
            <tag> 实例 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据库事务</title>
      <link href="/2018/04/07/database-transaction/"/>
      <url>/2018/04/07/database-transaction/</url>
      <content type="html"><![CDATA[<blockquote><p>数据库事务（Transaction）是指数据库管理系统执行过程中一个不可分割的逻辑单元，由有限的数据库操作语句组成。</p></blockquote><p>事务的执行步骤：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line">SQL execution 1 # rollback</span><br><span class="line">SQL execution 2 # rollback</span><br><span class="line">...</span><br><span class="line">SQL execution N # rollback</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>begin标识开始一个事务，后面的SQL语句是事务执行的操作，commit（提交）是结束当前事务并提交事务。而在语句执行过程中，可以回滚事务(Rollback)，回滚是指将数据恢复成事务开始之前的状态。</p><h1 id="为什么需要事务？"><a href="#为什么需要事务？" class="headerlink" title="为什么需要事务？"></a>为什么需要事务？</h1><p>数据库有自己的SQL语句，用户可以使用SQL语句操作数据库，那为什么需要事务呢？SQL语句能够直接修改数据库中的数据，但却无法保证数据的一致性。比如经典的转账问题：账户A向账户B转账，只用SQL语句无法保证从账户A扣款成功，同时从账户B增加对应的金额。所以<strong>事务是为了保证数据库中数据的一致性。</strong></p><h1 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h1><p>事务特性有哪些特性呢？</p><ul><li>原子性（Atomicity）:事务作为一个整体被执行，事务中的操作要么全部被执行，要么都不执行。</li><li>一致性（Consistency）：事务应确保数据库的状态一一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。不能存在事务对数据部分修改的情况。</li><li>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应该影响其他事务的执行。</li><li>持久性（Durability）：已经提交的事务对数据库的修改应该永远保存在数据库中。对数据库数据的修改应该持久化到硬盘中，即使服务器当机了，只要数据库能正常访问，就一定能够恢复事务成功结束时的标志。</li></ul><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>为说明数据库的特性，举一个经典的事务案例，账户Ａ向账号Ｂ转账100元，假设账户Ａ有800元，账户B有300元。要完成这个转账操作需要执行下面事务所包含的所有步骤，才能转账成功。</p><ol><li>读取账户A金额800元。</li><li>对账户A扣取100元，帐户A变为700元（内存）。</li><li>将结果700元写入到A账户中（硬盘）。</li><li>读取账户B金额300元。</li><li>对帐户B进行增加100元，账户B变为400元（内存）。</li><li>将结果400元写入到B账户中（硬盘）。</li></ol><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>原子性保证事务中的所有操作必须全部执行，或全部不执行。上面的转账事务包含6个操作，原子性保证上面的6个操作必须全部执行成功，转账事务才能成功。如果在第2步账号A金额不够100元，转账失败，事务<strong>回滚</strong>。如果在第6步，突然系统断电或系统崩溃，整个事务还是得回滚。<strong>回滚</strong>是指将数据恢复到事务执行之前的状态，也就相当于事务中的操作都不执行。</p><h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>一致性是指数据库中的数据从一个一致性状态转变到另一个一致性。不能出现部分修改数据的情况。在上面的案例中，转账前账号A与账号B金额总和是1100，转账后还是1100，这就是一致性。不能出现账户A扣钱成功，但账号B没收到钱，那肯定有问题了。</p><h2 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h2><p>在事务执行成功之前，即没有完成commit之前，查询账户A与账号B的金额，还是事务执行之前的数目。其他和A、B相关的并发转账事务或其他事务对当前转账不产生影响。</p><h2 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h2><p>当事务commit之后，即事务执行完成的时候，账户A与账户B的金额变成事务执行之后的数目，并持久化到硬盘中，之后的查询可以看到改变后的金额。即使系统故障，该事务也必须永久性生效。</p>]]></content>
      
      <categories>
          
          <category> 2018 </category>
          
          <category> 技术总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DB </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式之策略模式</title>
      <link href="/2018/03/31/strategy-pattern/"/>
      <url>/2018/03/31/strategy-pattern/</url>
      <content type="html"><![CDATA[<p>策略模式是比较常用也容易理解，它还充分体现了面向对象设计的原则：<strong>封装变化</strong>。</p><blockquote><p>策略模式(Strategy Pattern)是定义一组算法（业务规则），封装每个算法，这组算法可以相互替换。它是将算法的使用与实现进行分离。</p></blockquote><h1 id="策略模式介绍"><a href="#策略模式介绍" class="headerlink" title="策略模式介绍"></a>策略模式介绍</h1><p><img src="https://upload.wikimedia.org/wikipedia/commons/3/39/Strategy_Pattern_in_UML.png" alt="策略模式类图"></p><p>​                                        <strong>策略模式类图</strong></p><p>如上图所示，策略模式分为三个角色：</p><blockquote><p>Context 上下文</p><p>stategy 策略接口类</p><p>ConcreteStrategyA 具体策略类</p></blockquote><h1 id="不使用策略模式的例子"><a href="#不使用策略模式的例子" class="headerlink" title="不使用策略模式的例子"></a>不使用策略模式的例子</h1><p>先介绍一下不使用策略模式的例子。电影院的收银员肯定根据不同的客户进行分别收费，假设普通客户是原价，而VIP用户打88折，学生打九折。按照最普通的思路是这样实现的：</p><p>首先设计一个客户接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getType</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getTicketPrice</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后设计收银员进行收费：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CinemaCashier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 收费</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cashier</span><span class="params">(Member member)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"student"</span>.equals(member.getType())) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0.9</span>*member.getTicketPrice();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"vip"</span>.equals(member.getType())) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0.88</span>*member.getTicketPrice();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> member.getTicketPrice();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际收费流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.chason.patterns.strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cinema</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CinemaCashier cashier = <span class="keyword">new</span> CinemaCashier();</span><br><span class="line">    Member steudent = <span class="keyword">new</span> Student(<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">double</span> price = cashier.cashier(steudent);</span><br><span class="line">    System.out.println(steudent.getType() + <span class="string">":"</span> + price);</span><br><span class="line"></span><br><span class="line">    Member vip = <span class="keyword">new</span> Vip(<span class="number">30</span>);</span><br><span class="line">    price = cashier.cashier(vip);</span><br><span class="line">    System.out.println(vip.getType() + <span class="string">":"</span> + price);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line"><span class="comment">//student:27.0</span></span><br><span class="line"><span class="comment">//vip:26.4</span></span><br></pre></td></tr></table></figure><p>上面的收银员根据不同的用户类型采用不同的收费策略，这里采用if/else实现，这是最直接的实现方式。<strong>但是</strong>突然老板说要加一种超级会员，这就很无语了，超级会员实现上面的会员接口就可以了，但收费的行为逻辑就必须改动了，得再加一个逻辑判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cashier</span><span class="params">(Member member)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="string">"student"</span>.equals(member.getType())) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0.9</span>*member.getTicketPrice();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"vip"</span>.equals(member.getType())) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0.88</span>*member.getTicketPrice();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"vip+"</span>.equals(member.getType())) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0.8</span>*member.getTicketPrice();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> member.getTicketPrice();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>虽然看起来改动很小，但往往会导致代码的臃肿与腐烂。那导致上面的原因是什么呢？<strong>没有将变化进行封装。</strong></p><h1 id="使用策略模式进行改造"><a href="#使用策略模式进行改造" class="headerlink" title="使用策略模式进行改造"></a>使用策略模式进行改造</h1><p>下面采用策略模式进行改造。</p><p>首先是对客户类的封装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getType</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getTicketPrice</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">cashier</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收银员类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CinemaCashier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Member member;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 收费</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cashier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> member.cashier();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMember</span><span class="params">(Member member)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.member = member;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cinema</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CinemaCashier context = <span class="keyword">new</span> CinemaCashier();</span><br><span class="line"></span><br><span class="line">    Member strategy  = <span class="keyword">new</span> Student(<span class="number">30</span>);</span><br><span class="line">    cashier.setMember(strategy);</span><br><span class="line">    <span class="keyword">double</span> price = cashier.cashier();</span><br><span class="line">    System.out.println(strategy .getType() + <span class="string">":"</span> + price);</span><br><span class="line"></span><br><span class="line">    strategy  = <span class="keyword">new</span> Vip(<span class="number">30</span>);</span><br><span class="line">    cashier.setMember(strategy );</span><br><span class="line">    price = cashier.cashier();</span><br><span class="line">    System.out.println(strategy.getType() + <span class="string">":"</span> + price);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加新的收费策略</span></span><br><span class="line">    strategy  = <span class="keyword">new</span> VipPlus(<span class="number">30</span>);</span><br><span class="line">    cashier.setMember(strategy);</span><br><span class="line">    price = cashier.cashier();</span><br><span class="line">    System.out.println(strategy.getType() + <span class="string">":"</span> + price);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过改造后的代码，关键就在于针对不同用户的收费策略封装在不同对象中（本文是把策略方法直接放在用户对象中）。不同的策略对象是可以进行替换，并且context在确定的时间只能使用一种策略。当策略方法需要改动，或增加新的策略时，可以只用改动少量的代码或只用加代码就可以实现新功能的添加。</p><p>#总结</p><p>策略模式采用封装变化的方法，实现一组可以相互替换的算法或业务规则，而使用算法的应用环境或者说上下文根据具体情况决定采取哪一种策略。这样算法的实现与使用进行分离开来。算法的改动不会应用到算法的使用或其他算法。</p>]]></content>
      
      <categories>
          
          <category> 2018 </category>
          
          <category> 技术总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java代理</title>
      <link href="/2018/03/25/java-and-proxy/"/>
      <url>/2018/03/25/java-and-proxy/</url>
      <content type="html"><![CDATA[<blockquote><p>在使用Java的过程中，逐渐开始了解设计模式，其中代理模式是其中比较简单的设计模式，日常工作中也经常接触到代理模式的使用。</p></blockquote><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>代理模式（Proxy Pattern）使用代理对象完成用户请求，隐藏用户对真实对象的访问。代理模式其实非常容易理解。举个简单的例子： 小刘要找个房子，但他找房子并没有直接和房东联系，而是和中介联系。对于小刘而言，他作为客户并没有和房东（真实对象）打交道，只和中介（代理对象）沟通。似乎房东不存在，但事实上中介必须得有房东的授权，在核心问题上还得请示房东。</p><p>在软件设计中，使用代理模式的场景也很多，比如为了系统的安全性屏蔽客户端访问真实的对象，或者为了屏蔽真实对象的实现细节，也可能是为了提升系统性能，对真实对象进行封装，到使用时候才进行初始化，从而达到延迟加载的目的。</p><h2 id="代理模式架构"><a href="#代理模式架构" class="headerlink" title="代理模式架构"></a>代理模式架构</h2><p>代理模式架构比较简单，如下图所示，</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/75/Proxy_pattern_diagram.svg/439px-Proxy_pattern_diagram.svg.png" alt="代理模式图片"></p><p>​                                        代理模式架构图</p><p>代理对象与真实对象实现同一主题接口，当客户端向真实对象发起请求时，代理对象调用真实对象进行操作。</p><h2 id="代理模式简单样例"><a href="#代理模式简单样例" class="headerlink" title="代理模式简单样例"></a>代理模式简单样例</h2><p>下面给出一个代码样例。</p><p><strong>主题接口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ISubject</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">doAction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>真实对象：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealObject</span> <span class="keyword">implements</span> <span class="title">ISubject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doAction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"RealObject do something!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Real object"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主题接口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyObject</span> <span class="keyword">implements</span> <span class="title">ISubject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RealObject realObject;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doAction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(realObject == <span class="keyword">null</span>) &#123;  <span class="comment">// 在真正使用的时候，才创建真实对象</span></span><br><span class="line">            realObject = <span class="keyword">new</span> RealObject();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"ProxyObject do something!"</span>);</span><br><span class="line">        <span class="comment">// 执行真实对象的方法</span></span><br><span class="line">        <span class="keyword">return</span> realObject.doAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"> ISubject subject = <span class="keyword">new</span> ProxyObject(); <span class="comment">//使用代理</span></span><br><span class="line"> subject.doAction(); </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>上面的代码实例是静态代理，下面介绍动态代理。动态代理是指在运行时动态生成代理类。</p><p>刚才的静态代理虽然看起来简单，但其实有很多缺点：</p><ol><li><p>代理类与真实类实现了相同的主题接口，代理对象与真实对象实现了相同的方法。这样就会出现大量的代码重复。如果主题接口增加一个方法，除了真实对象要实现这个方法外，代理对象也要实现这个方法。这样增加了维护的复杂度。</p></li><li><p>代理对象只能代理一种类型的对象。如果要代理多种类型的对象的话。每个真实对象都必须要有对应的代理对象。</p><p>​</p></li></ol><p>如果可以通过一个代理类完成全部的代理的功能，那就需要使用动态代理。静态代理是在编译阶段就已经确定代理对象，而动态代理实在运行时，通过反射机制实现动态代理，并且能够代理多种类型的对象。</p><h1 id="动态代理实现"><a href="#动态代理实现" class="headerlink" title="动态代理实现"></a>动态代理实现</h1><h2 id="JDK自带实现"><a href="#JDK自带实现" class="headerlink" title="JDK自带实现"></a>JDK自带实现</h2><p>动态代理类使用字节码动态生成加载技术，在运行时生成加载类。其中JDK自带实现动态代理功能，但功能较弱，只能生成同一个接口的代理类。下面对上面的实例进行改造：</p><p><strong>动态代理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> ISubject realObject; <span class="comment">//定义主题接口</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//如果第一次调用，生成真实对象</span></span><br><span class="line">        <span class="keyword">if</span>(realObject == <span class="keyword">null</span>)&#123;</span><br><span class="line">            realObject = <span class="keyword">new</span> RealObject();</span><br><span class="line">        &#125;</span><br><span class="line">         System.out.println(<span class="string">"ProxyObject do something!"</span>);</span><br><span class="line">        <span class="comment">// 返回真实对象完成实际的操作 </span></span><br><span class="line">         <span class="keyword">return</span> method.invoke(realObject, args);  </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面实现了Handler,类似于上面代理类中具体逻辑。</p><p><strong>生成动态代理对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bigdata.spitter.featch;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> ISubject realObject;<span class="comment">//定义主题接口</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//如果第一次调用，生成真实对象</span></span><br><span class="line">        <span class="keyword">if</span>(realObject == <span class="keyword">null</span>)&#123;</span><br><span class="line">            realObject = <span class="keyword">new</span> RealObject();</span><br><span class="line">        &#125;</span><br><span class="line">         System.out.println(<span class="string">"ProxyObject do something!"</span>);</span><br><span class="line">        <span class="comment">// 返回真实对象完成实际的操作 </span></span><br><span class="line">        <span class="comment">//  return realObject.doAction();</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(realObject, args);  </span><br><span class="line">&#125; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ISubject <span class="title">createProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ISubject proxy = (ISubject)Proxy.newProxyInstance(</span><br><span class="line">        ClassLoader.getSystemClassLoader(), <span class="keyword">new</span> Class[]&#123;ISubject.class&#125;, <span class="keyword">new</span> SubjectHandler());</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        SubjectHandler subjectHandler = <span class="keyword">new</span> SubjectHandler();  </span><br><span class="line">        ISubject proxy = (ISubject)subjectHandler.createProxy();  </span><br><span class="line">        proxy.doAction();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是基于JDK自带的动态代理实现方式，代理类逻辑由SubjectHandler，生成代理类后，由newProxyInstance()方法返回代理类的实例，一个动态代理就完成了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文讲述了代理模式、静态代理与动态代理的区别，还有基于JDK自带功能动态代理的实现。总而言之，代理就是屏蔽或隐藏真实对象的行为，避免暴露更多的对象信息，降低客户端使用真实对象的复杂度。</p>]]></content>
      
      <categories>
          
          <category> 2018 </category>
          
          <category> 技术总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RESTful API介绍</title>
      <link href="/2018/03/17/restful-api/"/>
      <url>/2018/03/17/restful-api/</url>
      <content type="html"><![CDATA[<p>REST，刚接触这个词的时候，还以为是reset，后来又以为是rest(休息)，后来才知道它是英文“Representational State Transfer”的缩写，取其首字母得到REST。这段英文的翻译可以为“表现层状态转化”。它是Roy Thomas Fielding博士于2000年在他的博士论文中提出来的一种万维网软件架构风格。</p><h1 id="REST理解"><a href="#REST理解" class="headerlink" title="REST理解"></a>REST理解</h1><p>刚听这个词是不是很蒙，即使看了上面的介绍，是不是也觉得表现层状态转化是什么鬼？<br>那下面我进行详细解释<br>表现层（Representation）是指资源（Resources）的表现层。资源，其实就是网络上的可以认知的资源，比如文档、音乐、视频。可以通过URI(统一资源定位符)进行访问。</p><p>状态转化是指客户端与服务端的互动过程中，这必然涉及到数据与状态的变化。</p><p>RESET架构究竟是什么呢？</p><ol><li>每个URI标识互联网上的资源</li><li>连接是无状态的</li><li>客户端通过HTTP常用方法，对服务器端资源进行操作，实现”表现层状态转化”。</li></ol><h1 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h1><p>HTTP总共定义了八个方法，最常见的有4个，而设计RESTful接口的时候，应该遵循“安全性”与“幂等性”的要求</p><ul><li>安全性：无论请求多少次，都不会改变资源的状态。比如GET操作，无论执行多少遍，都不会改变资源的状态。所以对于GET类API，在编写应用端代码时，切记要尽可能避免出现删除或者更新数据的逻辑。</li><li>幂等性：无论是执行一次，还是执行多次，效果是等价的，比如 DELETE，PUT操作。以PUT操作为例，更新一次和更新多次，实际结果都是更新后的结果了。<br>具有安全性的方法：GET、HEAD、OPTIONS<br>具有幂等性的方法：GET、PUT、DELETE</li></ul><blockquote><p>GET(SELECT) -&gt; 查询操作,从服务器中取出资源<br>POST(CREATE) -&gt; 添加操作，在服务器新建资源<br>PUT(UPDATE) -&gt; 在服务器更新资源（客户端提供改变后的完整资源）。<br>PATCH(UPDATE) -&gt; 服务器更新资源（客户端提供改变的属性）<br>DELETE(DELETE) -&gt; 从服务器删除资源<br>另外两个不常用<br>HEAD -&gt; 获取资源的元数据。<br>OPTIONS -&gt; 获取信息，关于资源的哪些属性是客户端可以改变的。</p></blockquote><h1 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h1><p>REST是一种软件架构风格，并不是一种具体的标准。而在实际的后台开发过程中，逐渐变成面向接口进行开发，而为了让接口更加便于理解，更加规范，更加便于规范，业界逐渐开始采用REST风格。于是乎产生了具有REST风格的web API，而大家称之为RESTful API。</p><p>为了区分一般API与RESTful API,下面我先给出一个一般API，再给出RESTful API。</p><blockquote><p>POST <a href="http://localhost:8080/createUser" target="_blank" rel="noopener">http://localhost:8080/createUser</a><br>GET <a href="http://localhost:8080/getUser?id=123" target="_blank" rel="noopener">http://localhost:8080/getUser?id=123</a></p></blockquote><p>看完是不是觉得很熟悉，下面给出对应的RESTful 接口</p><blockquote><p>POST <a href="http://localhost:8080/users" target="_blank" rel="noopener">http://localhost:8080/users</a><br>GET <a href="http://localhost:8080/users/123" target="_blank" rel="noopener">http://localhost:8080/users/123</a></p></blockquote><h1 id="RESTful-API-常见设计错误"><a href="#RESTful-API-常见设计错误" class="headerlink" title="RESTful API 常见设计错误"></a>RESTful API 常见设计错误</h1><p><strong>URI包含动词。</strong>这是最常见的错误。RESTful 接口应该是采用对应的HTTP动词作为操作，而后面的URL链接标识具体的资源，它表示资源的状态转移。”资源”表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中。<br>举例来说，某个URI是/users/show/1，其中show是动词，这个URI就设计错了，正确的写法应该是/posts/1，然后用GET方法表示show。</p><p><strong>使用名词单数</strong><br>为了不混淆名词的单复数。保持简单，只用复数名词定义所有资源。<br>/cars 代替 /car<br>/users 代替 /user<br>/products 代替 /product<br>/settings 代替 /settings</p><p><strong>名词使用驼峰模式或眼镜蛇模式</strong>。资源名称应该尽量采用小写或使用”-“进行连接<br>/product-name 代替 /productName</p><h1 id="RESTful-API具体实例"><a href="#RESTful-API具体实例" class="headerlink" title="RESTful API具体实例"></a>RESTful API具体实例</h1><p>RESTful API常见路径为：<strong>/版本/模块/资源/{标识}/集合</strong>。<br>下面是具体样例</p><blockquote><p>/user/{uid}/frends -&gt; 好友列表<br>/user/{uid}/followers -&gt; 关注列表<br>GET /tickets # 获取ticket列表<br>GET /tickets/12 # 查看某个具体的ticket<br>POST /tickets # 新建一个ticket<br>PUT /tickets/12 # 更新ticket 12.<br>DELETE /tickets/12 #删除ticekt 12  </p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实RESTful API就是采用REST架构风格的API，便于理解与规范开发。而REST架构风格就是使用HTTP名词作为操作，而操作的对象是URL对应的资源。</p>]]></content>
      
      <categories>
          
          <category> 2018 </category>
          
          <category> 技术总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> api </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Open api安全设计与实现</title>
      <link href="/2018/03/11/open-api-security/"/>
      <url>/2018/03/11/open-api-security/</url>
      <content type="html"><![CDATA[<p>随着微服务架构的盛行及前后端的分离，后端开发逐渐转向开发独立的接口。接口一般给前端或者内部调用，一般来说是可以说是安全的。但如果要将接口暴露给第三方的话，会产生很多安全隐患。本文针对一些对外暴露的接口，即Open API，如何保证其安全，基于网上的资料，设计了一个Open API的安全加密方案，并给出了原型实现。</p><h2 id="接口安全标准"><a href="#接口安全标准" class="headerlink" title="接口安全标准"></a>接口安全标准</h2><ol><li>有调用者身份</li><li>请求的唯一性</li><li>请求的参数不能被篡改</li><li>请求的有效时间</li></ol><h2 id="接口安全实现原理"><a href="#接口安全实现原理" class="headerlink" title="接口安全实现原理"></a>接口安全实现原理</h2><p>要保证接口安全地对外暴露，基于上面的安全标准，一般来说采用对接口参数进行加密签名，或者基于OAuth2的认证进行保证接口安全。</p><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><p>结合网上的实现方式，本文做了以下设计</p><p>对于第三方或者外部系统调用内部API时，必须对请求参数进行签名加密，并且还要传入Token进行认证，为了保证请求的有效时间还加入时间戳。Token可以确保接口安全标准的1与2两点，而对请求参数加密能保证请求参数不能被篡改。相信这样的实现能够确保一般的Open API的安全性。<br>具体时序图如下所示：<br> <img src="https://raw.githubusercontent.com/cangqiong/blog-web/master/images/API签名加密.png" alt="image"></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><ol><li>第三方从内部系统获取Token</li><li>对除签名外的所有请求参数按key做的升序排列。例如：有c=3,b=2,a=1三个参，另加上时间戳后,按key排序后为：a=1，b=2，c=3,timestamp=12345678。</li><li>把参数名和参数值连接成字符串，得到拼装字符：a1b2c3_timestamp12345678</li><li>用获取到的Token对请求上面的拼接字符串进行加密，MD5或DES均可。</li><li>将该请求参数一起发过去后，被调用端基于对时间戳的有效性与Token的有效性，与签名的正确性进行判断，从而能够保证API的安全。</li></ol><p>PS： 被调用方在验证对应的请求参数之前，还可以对请求的API进行判断，看是否在开放白名单中，用户是否有访问该API的权限。</p><h2 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h2><p>如何获取如下的带签名的URL呢：</p><blockquote><p><a href="http://localhost:8081/hello/sayHello?name=世界&amp;token=ec4f2d80e1e5f53fe77a5f1bc7ac1972&amp;timestamp=1520776118141&amp;appkey=1a9c3039af0d4bc1d08d6daaf9221fc7" target="_blank" rel="noopener">http://localhost:8081/hello/sayHello?name=世界&amp;token=ec4f2d80e1e5f53fe77a5f1bc7ac1972&amp;timestamp=1520776118141&amp;appkey=1a9c3039af0d4bc1d08d6daaf9221fc7</a></p></blockquote><p>初始的URL：<a href="http://localhost:8081/hello/sayHello?name=世界&amp;timestamp=1520776118141" target="_blank" rel="noopener">http://localhost:8081/hello/sayHello?name=世界&amp;timestamp=1520776118141</a><br>请求Token方式略过不提。<br>通过下面两个方法，将请求字符串进行排序，获取升序排序的字符串name世界timestamp152077611814<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">getUrlParams</span><span class="params">(String param)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (StringUtil.isEmptyOrNull(param)) &#123;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] params = param.split(<span class="string">"&amp;"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">        String[] p = params[i].split(<span class="string">"="</span>);</span><br><span class="line">        <span class="keyword">if</span> (p.length == <span class="number">2</span>) &#123;</span><br><span class="line">            map.put(p[<span class="number">0</span>], p[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getUrlParamsByMap</span><span class="params">(Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        sb.append(entry.getKey()).append(entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后基于Token进行加密，作为签名：appkey=1a9c3039af0d4bc1d08d6daaf9221fc7<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">md5Sign</span><span class="params">(String token, String originStr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DigestUtils.md5DigestAsHex((token + originStr).getBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后进行传输到被调用方进行验证<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!queryStrMap.containsKey(APPKEY) || !queryStrMap.containsKey(TOKEN) || !queryStrMap.containsKey(TIMESTAMP)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuinessException(SystemConstantEnum.REQUEEST_INVALID.getCode(), SystemConstantEnum.REQUEEST_INVALID.getMsg());</span><br><span class="line">&#125;</span><br><span class="line">String token = queryStrMap.get(TOKEN).toString();</span><br><span class="line">String timeStamp = queryStrMap.get(TIMESTAMP).toString();</span><br><span class="line">String sign = queryStrMap.get(APPKEY).toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证该请求是否应失效</span></span><br><span class="line"><span class="keyword">long</span> requestTime = Long.parseLong(timeStamp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> diffTime = System.currentTimeMillis() - requestTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (diffTime &lt; <span class="number">0</span> || diffTime &gt; maxDiffTime) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuinessException(SystemConstantEnum.REQUEEST_INVALID.getCode(), SystemConstantEnum.REQUEEST_INVALID.getMsg());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证Token是否存在且有效</span></span><br><span class="line"><span class="keyword">if</span> (TokenUtil.getUiid(token) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuinessException(SystemConstantEnum.TOKEN_INVALID.getCode(), SystemConstantEnum.TOKEN_INVALID.getMsg());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断该接口是否开放</span></span><br><span class="line">ApiBlankList apiBlankList = <span class="keyword">new</span> ApiBlankList();</span><br><span class="line">String apiPath = requestMethod + <span class="string">" "</span> + requestUri;</span><br><span class="line">apiBlankList.setApi(apiPath);</span><br><span class="line">List&lt;ApiBlankList&gt; apiBlankListList = apiBlankListMapper.select(apiBlankList);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (CollectionUtils.isEmpty(apiBlankListList)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuinessException(SystemConstantEnum.API_REFUSE_ACCESS.getCode(), SystemConstantEnum.API_REFUSE_ACCESS.getMsg());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断该用户是否有权限访问该接口</span></span><br><span class="line">String uiid = TokenUtil.getUiid(token);</span><br><span class="line">UserApi userApi = <span class="keyword">new</span> UserApi();</span><br><span class="line">userApi.setApiPath(apiPath);</span><br><span class="line">userApi.setUiid(uiid);</span><br><span class="line">List&lt;UserApi&gt; userApis = userApiMapper.select(userApi);</span><br><span class="line"><span class="keyword">if</span> (CollectionUtils.isEmpty(userApis)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuinessException(SystemConstantEnum.API_REFUSE_ACCESS.getCode(), SystemConstantEnum.API_REFUSE_ACCESS.getMsg());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证签名是否正确</span></span><br><span class="line">String signStr = getSign(queryString);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!sign.equals(signStr)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuinessException(SystemConstantEnum.SIGN_NOT_CORRECT.getCode(), SystemConstantEnum.SIGN_NOT_CORRECT.getMsg());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是本文提出的基于Token与签名结合的安全设计与代码实现。如有不足之处，请发邮件告知或在github上提issue。<br>github地址：<a href="https://github.com/cangqiong/open-api-security" target="_blank" rel="noopener">open-api-security</a></p><p>参考文章：<br><a href="https://www.cnblogs.com/codeon/p/5900914.html?from=timeline&amp;isappinstalled=0" target="_blank" rel="noopener">如何写出安全的API接口？接口参数加密签名设计思路</a></p>]]></content>
      
      <categories>
          
          <category> 2018 </category>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码实现 </tag>
            
            <tag> Open api </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
