<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>数据库事务</title>
      <link href="/2018/04/07/database-transaction/"/>
      <content type="html"><![CDATA[<blockquote><p>数据库事务（Transaction）是指数据库管理系统执行过程中一个不可分割的逻辑单元，由有限的数据库操作语句组成。</p></blockquote><p>事务的执行步骤：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line">SQL execution 1 # rollback</span><br><span class="line">SQL execution 2 # rollback</span><br><span class="line">...</span><br><span class="line">SQL execution N # rollback</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>begin标识开始一个事务，后面的SQL语句是事务执行的操作，commit（提交）是结束当前事务并提交事务。而在语句执行过程中，可以回滚事务(Rollback)，回滚是指将数据恢复成事务开始之前的状态。</p><p>##为什么需要事务？</p><p>数据库有自己的SQL语句，用户可以使用SQL语句操作数据库，那为什么需要事务呢？SQL语句能够直接修改数据库中的数据，但却无法保证数据的一致性。比如经典的转账问题：账户A向账户B转账，只用SQL语句无法保证从账户A扣款成功，同时从账户B增加对应的金额。所以<strong>事务是为了保证数据库中数据的一致性。</strong></p><h1 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h1><p>事务特性有哪些特性呢？</p><ul><li>原子性（Atomicity）:事务作为一个整体被执行，事务中的操作要么全部被执行，要么都不执行。</li><li>一致性（Consistency）：事务应确保数据库的状态一一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。不能存在事务对数据部分修改的情况。</li><li>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应该影响其他事务的执行。</li><li>持久性（Durability）：已经提交的事务对数据库的修改应该永远保存在数据库中。对数据库数据的修改应该持久化到硬盘中，即使服务器当机了，只要数据库能正常访问，就一定能够恢复事务成功结束时的标志。</li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>为说明数据库的特性，举一个经典的事务案例，账户Ａ向账号Ｂ转账100元，假设账户Ａ有800元，账户B有300元。要完成这个转账操作需要执行下面事务所包含的所有步骤，才能转账成功。</p><ol><li>读取账户A金额800元。</li><li>对账户A扣取100元，帐户A变为700元（内存）。</li><li>将结果700元写入到A账户中（硬盘）。</li><li>读取账户B金额300元。</li><li>对帐户B进行增加100元，账户B变为400元（内存）。</li><li>将结果400元写入到B账户中（硬盘）。</li></ol><p>###原子性</p><p>原子性保证事务中的所有操作必须全部执行，或全部不执行。上面的转账事务包含6个操作，原子性保证上面的6个操作必须全部执行成功，转账事务才能成功。如果在第2步账号A金额不够100元，转账失败，事务<strong>回滚</strong>。如果在第6步，突然系统断电或系统崩溃，整个事务还是得回滚。<strong>回滚</strong>是指将数据恢复到事务执行之前的状态，也就相当于事务中的操作都不执行。</p><p>###一致性</p><p>一致性是指数据库中的数据从一个一致性状态转变到另一个一致性。不能出现部分修改数据的情况。在上面的案例中，转账前账号A与账号B金额总和是1100，转账后还是1100，这就是一致性。不能出现账户A扣钱成功，但账号B没收到钱，那肯定有问题了。</p><p>###隔离性</p><p>在事务执行成功之前，即没有完成commit之前，查询账户A与账号B的金额，还是事务执行之前的数目。其他和A、B相关的并发转账事务或其他事务对当前转账不产生影响。</p><p>###持久性</p><p>当事务commit之后，即事务执行完成的时候，账户A与账户B的金额变成事务执行之后的数目，并持久化到硬盘中，之后的查询可以看到改变后的金额。即使系统故障，该事务也必须永久性生效。</p>]]></content>
      
      <categories>
          
          <category> 2018 </category>
          
          <category> 技术总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DB </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>策略模式</title>
      <link href="/2018/03/31/strategy-pattern/"/>
      <content type="html"><![CDATA[<p>策略模式是比较常用也容易理解，它还充分体现了面向对象设计的原则：<strong>封装变化</strong>。</p><blockquote><p>策略模式(Strategy Pattern)是定义一组算法（业务规则），封装每个算法，这组算法可以相互替换。它是将算法的使用与实现进行分离。</p></blockquote><h1 id="策略模式介绍"><a href="#策略模式介绍" class="headerlink" title="策略模式介绍"></a>策略模式介绍</h1><p><img src="https://upload.wikimedia.org/wikipedia/commons/3/39/Strategy_Pattern_in_UML.png" alt="策略模式类图"></p><p>​                                        <strong>策略模式类图</strong></p><p>如上图所示，策略模式分为三个角色：</p><blockquote><p>Context 上下文</p><p>stategy 策略接口类</p><p>ConcreteStrategyA 具体策略类</p></blockquote><h1 id="不使用策略模式的例子"><a href="#不使用策略模式的例子" class="headerlink" title="不使用策略模式的例子"></a>不使用策略模式的例子</h1><p>先介绍一下不使用策略模式的例子。电影院的收银员肯定根据不同的客户进行分别收费，假设普通客户是原价，而VIP用户打88折，学生打九折。按照最普通的思路是这样实现的：</p><p>首先设计一个客户接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getType</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getTicketPrice</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后设计收银员进行收费：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CinemaCashier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 收费</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cashier</span><span class="params">(Member member)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"student"</span>.equals(member.getType())) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0.9</span>*member.getTicketPrice();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"vip"</span>.equals(member.getType())) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0.88</span>*member.getTicketPrice();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> member.getTicketPrice();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际收费流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.chason.patterns.strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cinema</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CinemaCashier cashier = <span class="keyword">new</span> CinemaCashier();</span><br><span class="line">    Member steudent = <span class="keyword">new</span> Student(<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">double</span> price = cashier.cashier(steudent);</span><br><span class="line">    System.out.println(steudent.getType() + <span class="string">":"</span> + price);</span><br><span class="line"></span><br><span class="line">    Member vip = <span class="keyword">new</span> Vip(<span class="number">30</span>);</span><br><span class="line">    price = cashier.cashier(vip);</span><br><span class="line">    System.out.println(vip.getType() + <span class="string">":"</span> + price);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line"><span class="comment">//student:27.0</span></span><br><span class="line"><span class="comment">//vip:26.4</span></span><br></pre></td></tr></table></figure><p>上面的收银员根据不同的用户类型采用不同的收费策略，这里采用if/else实现，这是最直接的实现方式。<strong>但是</strong>突然老板说要加一种超级会员，这就很无语了，超级会员实现上面的会员接口就可以了，但收费的行为逻辑就必须改动了，得再加一个逻辑判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cashier</span><span class="params">(Member member)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="string">"student"</span>.equals(member.getType())) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0.9</span>*member.getTicketPrice();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"vip"</span>.equals(member.getType())) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0.88</span>*member.getTicketPrice();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"vip+"</span>.equals(member.getType())) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0.8</span>*member.getTicketPrice();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> member.getTicketPrice();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>虽然看起来改动很小，但往往会导致代码的臃肿与腐烂。那导致上面的原因是什么呢？<strong>没有将变化进行封装。</strong></p><h1 id="使用策略模式进行改造"><a href="#使用策略模式进行改造" class="headerlink" title="使用策略模式进行改造"></a>使用策略模式进行改造</h1><p>下面采用策略模式进行改造。</p><p>首先是对客户类的封装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getType</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getTicketPrice</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">cashier</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收银员类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CinemaCashier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Member member;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 收费</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cashier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> member.cashier();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMember</span><span class="params">(Member member)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.member = member;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cinema</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CinemaCashier context = <span class="keyword">new</span> CinemaCashier();</span><br><span class="line"></span><br><span class="line">    Member strategy  = <span class="keyword">new</span> Student(<span class="number">30</span>);</span><br><span class="line">    cashier.setMember(strategy);</span><br><span class="line">    <span class="keyword">double</span> price = cashier.cashier();</span><br><span class="line">    System.out.println(strategy .getType() + <span class="string">":"</span> + price);</span><br><span class="line"></span><br><span class="line">    strategy  = <span class="keyword">new</span> Vip(<span class="number">30</span>);</span><br><span class="line">    cashier.setMember(strategy );</span><br><span class="line">    price = cashier.cashier();</span><br><span class="line">    System.out.println(strategy.getType() + <span class="string">":"</span> + price);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加新的收费策略</span></span><br><span class="line">    strategy  = <span class="keyword">new</span> VipPlus(<span class="number">30</span>);</span><br><span class="line">    cashier.setMember(strategy);</span><br><span class="line">    price = cashier.cashier();</span><br><span class="line">    System.out.println(strategy.getType() + <span class="string">":"</span> + price);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过改造后的代码，关键就在于针对不同用户的收费策略封装在不同对象中（本文是把策略方法直接放在用户对象中）。不同的策略对象是可以进行替换，并且context在确定的时间只能使用一种策略。当策略方法需要改动，或增加新的策略时，可以只用改动少量的代码或只用加代码就可以实现新功能的添加。</p><p>#总结</p><p>策略模式采用封装变化的方法，实现一组可以相互替换的算法或业务规则，而使用算法的应用环境或者说上下文根据具体情况决定采取哪一种策略。这样算法的实现与使用进行分离开来。算法的改动不会应用到算法的使用或其他算法。</p>]]></content>
      
      <categories>
          
          <category> 2018 </category>
          
          <category> 技术总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java代理</title>
      <link href="/2018/03/25/java-and-proxy/"/>
      <content type="html"><![CDATA[<blockquote><p>在使用Java的过程中，逐渐开始了解设计模式，其中代理模式是其中比较简单的设计模式，日常工作中也经常接触到代理模式的使用。</p></blockquote><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>代理模式（Proxy Pattern）使用代理对象完成用户请求，隐藏用户对真实对象的访问。代理模式其实非常容易理解。举个简单的例子： 小刘要找个房子，但他找房子并没有直接和房东联系，而是和中介联系。对于小刘而言，他作为客户并没有和房东（真实对象）打交道，只和中介（代理对象）沟通。似乎房东不存在，但事实上中介必须得有房东的授权，在核心问题上还得请示房东。</p><p>在软件设计中，使用代理模式的场景也很多，比如为了系统的安全性屏蔽客户端访问真实的对象，或者为了屏蔽真实对象的实现细节，也可能是为了提升系统性能，对真实对象进行封装，到使用时候才进行初始化，从而达到延迟加载的目的。</p><h2 id="代理模式架构"><a href="#代理模式架构" class="headerlink" title="代理模式架构"></a>代理模式架构</h2><p>代理模式架构比较简单，如下图所示，</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/75/Proxy_pattern_diagram.svg/439px-Proxy_pattern_diagram.svg.png" alt="代理模式图片"></p><p>​                                        代理模式架构图</p><p>代理对象与真实对象实现同一主题接口，当客户端向真实对象发起请求时，代理对象调用真实对象进行操作。</p><h2 id="代理模式简单样例"><a href="#代理模式简单样例" class="headerlink" title="代理模式简单样例"></a>代理模式简单样例</h2><p>下面给出一个代码样例。</p><p><strong>主题接口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ISubject</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">doAction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>真实对象：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealObject</span> <span class="keyword">implements</span> <span class="title">ISubject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doAction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"RealObject do something!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Real object"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主题接口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyObject</span> <span class="keyword">implements</span> <span class="title">ISubject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RealObject realObject;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doAction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(realObject == <span class="keyword">null</span>) &#123;  <span class="comment">// 在真正使用的时候，才创建真实对象</span></span><br><span class="line">            realObject = <span class="keyword">new</span> RealObject();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"ProxyObject do something!"</span>);</span><br><span class="line">        <span class="comment">// 执行真实对象的方法</span></span><br><span class="line">        <span class="keyword">return</span> realObject.doAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"> ISubject subject = <span class="keyword">new</span> ProxyObject(); <span class="comment">//使用代理</span></span><br><span class="line"> subject.doAction(); </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>上面的代码实例是静态代理，下面介绍动态代理。动态代理是指在运行时动态生成代理类。</p><p>刚才的静态代理虽然看起来简单，但其实有很多缺点：</p><ol><li><p>代理类与真实类实现了相同的主题接口，代理对象与真实对象实现了相同的方法。这样就会出现大量的代码重复。如果主题接口增加一个方法，除了真实对象要实现这个方法外，代理对象也要实现这个方法。这样增加了维护的复杂度。</p></li><li><p>代理对象只能代理一种类型的对象。如果要代理多种类型的对象的话。每个真实对象都必须要有对应的代理对象。</p><p>​</p></li></ol><p>如果可以通过一个代理类完成全部的代理的功能，那就需要使用动态代理。静态代理是在编译阶段就已经确定代理对象，而动态代理实在运行时，通过反射机制实现动态代理，并且能够代理多种类型的对象。</p><h1 id="动态代理实现"><a href="#动态代理实现" class="headerlink" title="动态代理实现"></a>动态代理实现</h1><h2 id="JDK自带实现"><a href="#JDK自带实现" class="headerlink" title="JDK自带实现"></a>JDK自带实现</h2><p>动态代理类使用字节码动态生成加载技术，在运行时生成加载类。其中JDK自带实现动态代理功能，但功能较弱，只能生成同一个接口的代理类。下面对上面的实例进行改造：</p><p><strong>动态代理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> ISubject realObject; <span class="comment">//定义主题接口</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//如果第一次调用，生成真实对象</span></span><br><span class="line">        <span class="keyword">if</span>(realObject == <span class="keyword">null</span>)&#123;</span><br><span class="line">            realObject = <span class="keyword">new</span> RealObject();</span><br><span class="line">        &#125;</span><br><span class="line">         System.out.println(<span class="string">"ProxyObject do something!"</span>);</span><br><span class="line">        <span class="comment">// 返回真实对象完成实际的操作 </span></span><br><span class="line">         <span class="keyword">return</span> method.invoke(realObject, args);  </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面实现了Handler,类似于上面代理类中具体逻辑。</p><p><strong>生成动态代理对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bigdata.spitter.featch;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> ISubject realObject;<span class="comment">//定义主题接口</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//如果第一次调用，生成真实对象</span></span><br><span class="line">        <span class="keyword">if</span>(realObject == <span class="keyword">null</span>)&#123;</span><br><span class="line">            realObject = <span class="keyword">new</span> RealObject();</span><br><span class="line">        &#125;</span><br><span class="line">         System.out.println(<span class="string">"ProxyObject do something!"</span>);</span><br><span class="line">        <span class="comment">// 返回真实对象完成实际的操作 </span></span><br><span class="line">        <span class="comment">//  return realObject.doAction();</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(realObject, args);  </span><br><span class="line">&#125; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ISubject <span class="title">createProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ISubject proxy = (ISubject)Proxy.newProxyInstance(</span><br><span class="line">        ClassLoader.getSystemClassLoader(), <span class="keyword">new</span> Class[]&#123;ISubject.class&#125;, <span class="keyword">new</span> SubjectHandler());</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        SubjectHandler subjectHandler = <span class="keyword">new</span> SubjectHandler();  </span><br><span class="line">        ISubject proxy = (ISubject)subjectHandler.createProxy();  </span><br><span class="line">        proxy.doAction();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是基于JDK自带的动态代理实现方式，代理类逻辑由SubjectHandler，生成代理类后，由newProxyInstance()方法返回代理类的实例，一个动态代理就完成了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文讲述了代理模式、静态代理与动态代理的区别，还有基于JDK自带功能动态代理的实现。总而言之，代理就是屏蔽或隐藏真实对象的行为，避免暴露更多的对象信息，降低客户端使用真实对象的复杂度。</p>]]></content>
      
      <categories>
          
          <category> 2018 </category>
          
          <category> 技术总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RESTful API介绍</title>
      <link href="/2018/03/17/restful-api/"/>
      <content type="html"><![CDATA[<p>REST，刚接触这个词的时候，还以为是reset，后来又以为是rest(休息)，后来才知道它是英文“Representational State Transfer”的缩写，取其首字母得到REST。这段英文的翻译可以为“表现层状态转化”。它是Roy Thomas Fielding博士于2000年在他的博士论文中提出来的一种万维网软件架构风格。</p><h1 id="REST理解"><a href="#REST理解" class="headerlink" title="REST理解"></a>REST理解</h1><p>刚听这个词是不是很蒙，即使看了上面的介绍，是不是也觉得表现层状态转化是什么鬼？<br>那下面我进行详细解释<br>表现层（Representation）是指资源（Resources）的表现层。资源，其实就是网络上的可以认知的资源，比如文档、音乐、视频。可以通过URI(统一资源定位符)进行访问。</p><p>状态转化是指客户端与服务端的互动过程中，这必然涉及到数据与状态的变化。</p><p>RESET架构究竟是什么呢？</p><ol><li>每个URI标识互联网上的资源</li><li>连接是无状态的</li><li>客户端通过HTTP常用方法，对服务器端资源进行操作，实现”表现层状态转化”。</li></ol><h1 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h1><p>HTTP总共定义了八个方法，最常见的有4个，而设计RESTful接口的时候，应该遵循“安全性”与“幂等性”的要求</p><ul><li>安全性：无论请求多少次，都不会改变资源的状态。比如GET操作，无论执行多少遍，都不会改变资源的状态。所以对于GET类API，在编写应用端代码时，切记要尽可能避免出现删除或者更新数据的逻辑。</li><li>幂等性：无论是执行一次，还是执行多次，效果是等价的，比如 DELETE，PUT操作。以PUT操作为例，更新一次和更新多次，实际结果都是更新后的结果了。<br>具有安全性的方法：GET、HEAD、OPTIONS<br>具有幂等性的方法：GET、PUT、DELETE</li></ul><blockquote><p>GET(SELECT) -&gt; 查询操作,从服务器中取出资源<br>POST(CREATE) -&gt; 添加操作，在服务器新建资源<br>PUT(UPDATE) -&gt; 在服务器更新资源（客户端提供改变后的完整资源）。<br>PATCH(UPDATE) -&gt; 服务器更新资源（客户端提供改变的属性）<br>DELETE(DELETE) -&gt; 从服务器删除资源<br>另外两个不常用<br>HEAD -&gt; 获取资源的元数据。<br>OPTIONS -&gt; 获取信息，关于资源的哪些属性是客户端可以改变的。</p></blockquote><h1 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h1><p>REST是一种软件架构风格，并不是一种具体的标准。而在实际的后台开发过程中，逐渐变成面向接口进行开发，而为了让接口更加便于理解，更加规范，更加便于规范，业界逐渐开始采用REST风格。于是乎产生了具有REST风格的web API，而大家称之为RESTful API。</p><p>为了区分一般API与RESTful API,下面我先给出一个一般API，再给出RESTful API。</p><blockquote><p>POST <a href="http://localhost:8080/createUser" target="_blank" rel="noopener">http://localhost:8080/createUser</a><br>GET <a href="http://localhost:8080/getUser?id=123" target="_blank" rel="noopener">http://localhost:8080/getUser?id=123</a></p></blockquote><p>看完是不是觉得很熟悉，下面给出对应的RESTful 接口</p><blockquote><p>POST <a href="http://localhost:8080/users" target="_blank" rel="noopener">http://localhost:8080/users</a><br>GET <a href="http://localhost:8080/users/123" target="_blank" rel="noopener">http://localhost:8080/users/123</a></p></blockquote><h1 id="RESTful-API-常见设计错误"><a href="#RESTful-API-常见设计错误" class="headerlink" title="RESTful API 常见设计错误"></a>RESTful API 常见设计错误</h1><p><strong>URI包含动词。</strong>这是最常见的错误。RESTful 接口应该是采用对应的HTTP动词作为操作，而后面的URL链接标识具体的资源，它表示资源的状态转移。”资源”表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中。<br>举例来说，某个URI是/users/show/1，其中show是动词，这个URI就设计错了，正确的写法应该是/posts/1，然后用GET方法表示show。</p><p><strong>使用名词单数</strong><br>为了不混淆名词的单复数。保持简单，只用复数名词定义所有资源。<br>/cars 代替 /car<br>/users 代替 /user<br>/products 代替 /product<br>/settings 代替 /settings</p><p><strong>名词使用驼峰模式或眼镜蛇模式</strong>。资源名称应该尽量采用小写或使用”-“进行连接<br>/product-name 代替 /productName</p><h1 id="RESTful-API具体实例"><a href="#RESTful-API具体实例" class="headerlink" title="RESTful API具体实例"></a>RESTful API具体实例</h1><p>RESTful API常见路径为：<strong>/版本/模块/资源/{标识}/集合</strong>。<br>下面是具体样例</p><blockquote><p>/user/{uid}/frends -&gt; 好友列表<br>/user/{uid}/followers -&gt; 关注列表<br>GET /tickets # 获取ticket列表<br>GET /tickets/12 # 查看某个具体的ticket<br>POST /tickets # 新建一个ticket<br>PUT /tickets/12 # 更新ticket 12.<br>DELETE /tickets/12 #删除ticekt 12  </p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实RESTful API就是采用REST架构风格的API，便于理解与规范开发。而REST架构风格就是使用HTTP名词作为操作，而操作的对象是URL对应的资源。</p>]]></content>
      
      <categories>
          
          <category> 2018 </category>
          
          <category> 技术总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> api </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Open api安全设计与实现</title>
      <link href="/2018/03/11/open-api-security/"/>
      <content type="html"><![CDATA[<p>随着微服务架构的盛行及前后端的分离，后端开发逐渐转向开发独立的接口。接口一般给前端或者内部调用，一般来说是可以说是安全的。但如果要将接口暴露给第三方的话，会产生很多安全隐患。本文针对一些对外暴露的接口，即Open API，如何保证其安全，基于网上的资料，设计了一个Open API的安全加密方案，并给出了原型实现。</p><h2 id="接口安全标准"><a href="#接口安全标准" class="headerlink" title="接口安全标准"></a>接口安全标准</h2><ol><li>有调用者身份</li><li>请求的唯一性</li><li>请求的参数不能被篡改</li><li>请求的有效时间</li></ol><h2 id="接口安全实现原理"><a href="#接口安全实现原理" class="headerlink" title="接口安全实现原理"></a>接口安全实现原理</h2><p>要保证接口安全地对外暴露，基于上面的安全标准，一般来说采用对接口参数进行加密签名，或者基于OAuth2的认证进行保证接口安全。</p><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><p>结合网上的实现方式，本文做了以下设计</p><p>对于第三方或者外部系统调用内部API时，必须对请求参数进行签名加密，并且还要传入Token进行认证，为了保证请求的有效时间还加入时间戳。Token可以确保接口安全标准的1与2两点，而对请求参数加密能保证请求参数不能被篡改。相信这样的实现能够确保一般的Open API的安全性。<br>具体时序图如下所示：<br> <img src="https://raw.githubusercontent.com/cangqiong/blog-web/master/images/API签名加密.png" alt="image"></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><ol><li>第三方从内部系统获取Token</li><li>对除签名外的所有请求参数按key做的升序排列。例如：有c=3,b=2,a=1三个参，另加上时间戳后,按key排序后为：a=1，b=2，c=3,timestamp=12345678。</li><li>把参数名和参数值连接成字符串，得到拼装字符：a1b2c3_timestamp12345678</li><li>用获取到的Token对请求上面的拼接字符串进行加密，MD5或DES均可。</li><li>将该请求参数一起发过去后，被调用端基于对时间戳的有效性与Token的有效性，与签名的正确性进行判断，从而能够保证API的安全。</li></ol><p>PS： 被调用方在验证对应的请求参数之前，还可以对请求的API进行判断，看是否在开放白名单中，用户是否有访问该API的权限。</p><h2 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h2><p>如何获取如下的带签名的URL呢：</p><blockquote><p><a href="http://localhost:8081/hello/sayHello?name=世界&amp;token=ec4f2d80e1e5f53fe77a5f1bc7ac1972&amp;timestamp=1520776118141&amp;appkey=1a9c3039af0d4bc1d08d6daaf9221fc7" target="_blank" rel="noopener">http://localhost:8081/hello/sayHello?name=世界&amp;token=ec4f2d80e1e5f53fe77a5f1bc7ac1972&amp;timestamp=1520776118141&amp;appkey=1a9c3039af0d4bc1d08d6daaf9221fc7</a></p></blockquote><p>初始的URL：<a href="http://localhost:8081/hello/sayHello?name=世界&amp;timestamp=1520776118141" target="_blank" rel="noopener">http://localhost:8081/hello/sayHello?name=世界&amp;timestamp=1520776118141</a><br>请求Token方式略过不提。<br>通过下面两个方法，将请求字符串进行排序，获取升序排序的字符串name世界timestamp152077611814<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">getUrlParams</span><span class="params">(String param)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (StringUtil.isEmptyOrNull(param)) &#123;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] params = param.split(<span class="string">"&amp;"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">        String[] p = params[i].split(<span class="string">"="</span>);</span><br><span class="line">        <span class="keyword">if</span> (p.length == <span class="number">2</span>) &#123;</span><br><span class="line">            map.put(p[<span class="number">0</span>], p[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getUrlParamsByMap</span><span class="params">(Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        sb.append(entry.getKey()).append(entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后基于Token进行加密，作为签名：appkey=1a9c3039af0d4bc1d08d6daaf9221fc7<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">md5Sign</span><span class="params">(String token, String originStr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DigestUtils.md5DigestAsHex((token + originStr).getBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后进行传输到被调用方进行验证<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!queryStrMap.containsKey(APPKEY) || !queryStrMap.containsKey(TOKEN) || !queryStrMap.containsKey(TIMESTAMP)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuinessException(SystemConstantEnum.REQUEEST_INVALID.getCode(), SystemConstantEnum.REQUEEST_INVALID.getMsg());</span><br><span class="line">&#125;</span><br><span class="line">String token = queryStrMap.get(TOKEN).toString();</span><br><span class="line">String timeStamp = queryStrMap.get(TIMESTAMP).toString();</span><br><span class="line">String sign = queryStrMap.get(APPKEY).toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证该请求是否应失效</span></span><br><span class="line"><span class="keyword">long</span> requestTime = Long.parseLong(timeStamp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> diffTime = System.currentTimeMillis() - requestTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (diffTime &lt; <span class="number">0</span> || diffTime &gt; maxDiffTime) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuinessException(SystemConstantEnum.REQUEEST_INVALID.getCode(), SystemConstantEnum.REQUEEST_INVALID.getMsg());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证Token是否存在且有效</span></span><br><span class="line"><span class="keyword">if</span> (TokenUtil.getUiid(token) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuinessException(SystemConstantEnum.TOKEN_INVALID.getCode(), SystemConstantEnum.TOKEN_INVALID.getMsg());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断该接口是否开放</span></span><br><span class="line">ApiBlankList apiBlankList = <span class="keyword">new</span> ApiBlankList();</span><br><span class="line">String apiPath = requestMethod + <span class="string">" "</span> + requestUri;</span><br><span class="line">apiBlankList.setApi(apiPath);</span><br><span class="line">List&lt;ApiBlankList&gt; apiBlankListList = apiBlankListMapper.select(apiBlankList);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (CollectionUtils.isEmpty(apiBlankListList)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuinessException(SystemConstantEnum.API_REFUSE_ACCESS.getCode(), SystemConstantEnum.API_REFUSE_ACCESS.getMsg());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断该用户是否有权限访问该接口</span></span><br><span class="line">String uiid = TokenUtil.getUiid(token);</span><br><span class="line">UserApi userApi = <span class="keyword">new</span> UserApi();</span><br><span class="line">userApi.setApiPath(apiPath);</span><br><span class="line">userApi.setUiid(uiid);</span><br><span class="line">List&lt;UserApi&gt; userApis = userApiMapper.select(userApi);</span><br><span class="line"><span class="keyword">if</span> (CollectionUtils.isEmpty(userApis)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuinessException(SystemConstantEnum.API_REFUSE_ACCESS.getCode(), SystemConstantEnum.API_REFUSE_ACCESS.getMsg());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证签名是否正确</span></span><br><span class="line">String signStr = getSign(queryString);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!sign.equals(signStr)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuinessException(SystemConstantEnum.SIGN_NOT_CORRECT.getCode(), SystemConstantEnum.SIGN_NOT_CORRECT.getMsg());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是本文提出的基于Token与签名结合的安全设计与代码实现。如有不足之处，请发邮件告知或在github上提issue。<br>github地址：<a href="https://github.com/cangqiong/open-api-security" target="_blank" rel="noopener">open-api-security</a></p><p>参考文章：<br><a href="https://www.cnblogs.com/codeon/p/5900914.html?from=timeline&amp;isappinstalled=0" target="_blank" rel="noopener">如何写出安全的API接口？接口参数加密签名设计思路</a></p>]]></content>
      
      <categories>
          
          <category> 2018 </category>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Open api </tag>
            
            <tag> 源码实现 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
